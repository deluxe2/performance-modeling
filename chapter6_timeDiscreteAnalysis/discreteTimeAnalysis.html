<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>discreteTimeAnalysis API documentation</title>
<meta name="description" content="The module provides a class for finite discrete distributions which are utilized for discrete-time analysis.
For example, discrete-time GI/GI/1 …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>discreteTimeAnalysis</code></h1>
</header>
<section id="section-intro">
<p>The module provides a class for finite discrete distributions which are utilized for discrete-time analysis.
For example, discrete-time GI/GI/1 systems can be analyzed with functions of the module.</p>
<p>(c) Tobias Hossfeld
(Aug 2021)</p>
<p>This module is part of the following book. The book is to be cited whenever the script is used (copyright CC BY-SA 4.0):</p>
<blockquote>
<p>Tran-Gia, P. &amp; Hossfeld, T. (2021).
Performance Modeling and Analysis of Communication Networks - A Lecture Note.
Würzburg University Press. <br>
<a href="https://doi.org/10.25972/WUP-978-3-95826-153-2">https://doi.org/10.25972/WUP-978-3-95826-153-2</a></p>
</blockquote>
<h2 id="example">Example</h2>
<p>We can easily define some discrete distribution and do computations with the corresponding random variables.
In the example, we consider the sum of two random variables, which requires the convolution of the corresponding probability mass functions.
The r.v. A follows a discrete uniform distribution in the range [0;10], while the r.v. B follows a negative binomial distribution,
which is defined through the mean and the coefficient of variation.</p>
<pre><code class="python-repl">&gt;&gt;&gt; import discreteTimeAnalysis as dt
&gt;&gt;&gt; A = dt.DU(a=0, b=10) % A ~ DU(0,10)
&gt;&gt;&gt; EX, cX = 2.0, 1.5   % mean EX and coefficient of variation cX
&gt;&gt;&gt; B = dt.NEGBIN(EX, cX) % negative binomial distribution
&gt;&gt;&gt; C = A + B % sum of random variables requires convolution of PMFs
&gt;&gt;&gt; C.plotCDF(label='A+B') % plot the CDF of the sum of A+B
</code></pre>
<h2 id="operators">Operators</h2>
<p>The module overloads the following operators, which make it convenient to implement comprehensive and well understandable code.</p>
<p><code>+</code> operator: The sum of two random variables means the convolution of their probability mass functions.
<code>A+B</code> calls the method <code><a title="discreteTimeAnalysis.DiscreteDistribution.conv" href="#discreteTimeAnalysis.DiscreteDistribution.conv">DiscreteDistribution.conv()</a></code> and is identical to <code>A.conv(B)</code>, see the example above.</p>
<p><code>-</code> operator: The difference of two random variables means the convolution of their probability mass functions.
<code>A-B</code> calls the method <code><a title="discreteTimeAnalysis.DiscreteDistribution.convNeg" href="#discreteTimeAnalysis.DiscreteDistribution.convNeg">DiscreteDistribution.convNeg()</a></code> and is identical to <code>A.convNeg(B)</code>.</p>
<p><code>&lt;</code> operator: The comparison is done based on means. Returns true if <code>A.mean() &lt; B.mean()</code></p>
<p><code>&lt;=</code> operator: The comparison is done based on means. Returns true if <code>A.mean() &lt;= B.mean()</code></p>
<p><code>&gt;</code> operator: The comparison is done based on means. Returns true if <code>A.mean() &gt; B.mean()</code></p>
<p><code>&gt;=</code> operator: The comparison is done based on means. Returns true if <code>A.mean() &gt;= B.mean()</code></p>
<p>'==' operator: The comparison is done based on means. For the equality comparison, the
threshold value <code><a title="discreteTimeAnalysis.comparisonEQ_eps" href="#discreteTimeAnalysis.comparisonEQ_eps">comparisonEQ_eps</a></code> is used for numerical reasons.
Returns true if <code>abs( A.mean() - B.mean() ) &lt;= comparisonEQ_eps</code>. This allows a compact
implementation of the power method.</p>
<p>'!=' operator: The comparison is done based on means. For the equality comparison, the
threshold value <code><a title="discreteTimeAnalysis.comparisonEQ_eps" href="#discreteTimeAnalysis.comparisonEQ_eps">comparisonEQ_eps</a></code> is used for numerical reasons.
Returns true if <code>abs( A.mean() - B.mean() ) &gt; comparisonEQ_eps</code>. This allows a compact
implementation of the power method.</p>
<p>'|' operator: This operator is used as a shortcut for <code><a title="discreteTimeAnalysis.DiscreteDistribution.conditionalRV" href="#discreteTimeAnalysis.DiscreteDistribution.conditionalRV">DiscreteDistribution.conditionalRV()</a></code> which returns a conditional random variable.</p>
<h2 id="notes">Notes</h2>
<p>The theory behind the module is described in the book in Chapter 6.
The text book is published as open access book and can be downloaded at
<a href="https://modeling.systems">https://modeling.systems</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
The module provides a class for finite discrete distributions which are utilized for discrete-time analysis.
For example, discrete-time GI/GI/1 systems can be analyzed with functions of the module.

(c) Tobias Hossfeld  (Aug 2021)

This module is part of the following book. The book is to be cited whenever the script is used (copyright CC BY-SA 4.0):

&gt;Tran-Gia, P. &amp; Hossfeld, T. (2021). 
&gt;Performance Modeling and Analysis of Communication Networks - A Lecture Note.
&gt;Würzburg University Press. &lt;br&gt;
&gt;https://doi.org/10.25972/WUP-978-3-95826-153-2


Example
-------
We can easily define some discrete distribution and do computations with the corresponding random variables.
In the example, we consider the sum of two random variables, which requires the convolution of the corresponding probability mass functions.
The r.v. A follows a discrete uniform distribution in the range [0;10], while the r.v. B follows a negative binomial distribution,
which is defined through the mean and the coefficient of variation.

&gt;&gt;&gt; import discreteTimeAnalysis as dt
&gt;&gt;&gt; A = dt.DU(a=0, b=10) % A ~ DU(0,10)
&gt;&gt;&gt; EX, cX = 2.0, 1.5   % mean EX and coefficient of variation cX
&gt;&gt;&gt; B = dt.NEGBIN(EX, cX) % negative binomial distribution
&gt;&gt;&gt; C = A + B % sum of random variables requires convolution of PMFs
&gt;&gt;&gt; C.plotCDF(label=&#39;A+B&#39;) % plot the CDF of the sum of A+B


Operators
---------
The module overloads the following operators, which make it convenient to implement comprehensive and well understandable code.

`+` operator: The sum of two random variables means the convolution of their probability mass functions. 
`A+B` calls the method `DiscreteDistribution.conv` and is identical to `A.conv(B)`, see the example above.

`-` operator: The difference of two random variables means the convolution of their probability mass functions. 
`A-B` calls the method `DiscreteDistribution.convNeg` and is identical to `A.convNeg(B)`.

`&lt;` operator: The comparison is done based on means. Returns true if `A.mean() &lt; B.mean()`

`&lt;=` operator: The comparison is done based on means. Returns true if `A.mean() &lt;= B.mean()`

`&gt;` operator: The comparison is done based on means. Returns true if `A.mean() &gt; B.mean()`

`&gt;=` operator: The comparison is done based on means. Returns true if `A.mean() &gt;= B.mean()`

&#39;==&#39; operator: The comparison is done based on means. For the equality comparison, the
threshold value `discreteTimeAnalysis.comparisonEQ_eps` is used for numerical reasons. 
Returns true if `abs( A.mean() - B.mean() ) &lt;= comparisonEQ_eps`. This allows a compact
implementation of the power method.

&#39;!=&#39; operator: The comparison is done based on means. For the equality comparison, the
threshold value `discreteTimeAnalysis.comparisonEQ_eps` is used for numerical reasons. 
Returns true if `abs( A.mean() - B.mean() ) &gt; comparisonEQ_eps`. This allows a compact
implementation of the power method.

&#39;|&#39; operator: This operator is used as a shortcut for `DiscreteDistribution.conditionalRV` which returns a conditional random variable.
 
Notes
-----
The theory behind the module is described in the book in Chapter 6. 
The text book is published as open access book and can be downloaded at
&lt;https://modeling.systems&gt;


&#34;&#34;&#34;

import numpy as np
import matplotlib.pyplot as plt
import math

comparisonEQ_eps = 1e-6
&#34;&#34;&#34;The variable is used for the numerical comparison of two random variables `A`and `B`. 
The comparison `A==B` returns true if `abs( A.mean() - B.mean() ) &lt;= comparisonEQ_eps`. 

&#34;&#34;&#34;

#%%    
class DiscreteDistribution:
    r&#34;&#34;&#34;The class implements finite discrete distributions representing discrete random variables.

    A discrete distribution reflects a random variable \( X \) and is defined 
    by its probability mass function (PMF). The random variable can take discrete values
    which are defined by the numpy array `xk` (sample space). The probability that the random variable
    takes a certain value is \( P(X=k)=p_k \). The probabilities are stored in the
    numpy array `pk`.
    

    Attributes
    ----------
    xk : numpy array
        Values of the distribution (sample space).
    pk : numpy array
        Probabilities corresponding to the sample space.
    name : string
        Arbitrary name of that distribution. 

    &#34;&#34;&#34;    
    
    def __init__(self, xk, pk, name=&#39;discrete distr.&#39;):         
        r&#34;&#34;&#34;A discrete distribution is initialized with value range `xk`and probabilities `pk`.
        
        For the initialization of a discrete random variable, the sample space `xk` and the corresponding
        probabilities `pk` are required. Both parameters are then stored as class attributes in form
        of numpy array (one-dimensional). In addition, an arbitrary `name` can be passed to the
        distribution which is used when printing an instance of the class, see e.g. 
        `DiscreteDistribution.describe`.

        Parameters
        ----------
        xk : numpy array or list
            Values of the distribution.
        pk : numpy array or list
            Probabilities corresponding to the values: \( P(X=xk)=pk \).
        name : string, optional (default &#39;discrete distr.&#39;)
            Name of the distribution for string representation.

        &#34;&#34;&#34;        
        assert len(xk)==len(pk) # same length        
        
        self.xmin = np.min(xk)
        self.xmax = np.max(xk)
        
        # adjust to vector xk without gaps
        self.xk = np.arange(self.xmin, self.xmax+1, dtype=&#39;int&#39;)
        self.pk = np.zeros( len(self.xk) )
        self.pk[xk-self.xmin] = pk
        self.name = name
        
    def mean(self):
        r&#34;&#34;&#34;Returns the mean value of the distribution \( E[X] \).
    
    
        Returns
        -------
        float
            Mean value.
            
        &#34;&#34;&#34;        
        return np.sum(self.xk*self.pk)
    
    def var(self):
        r&#34;&#34;&#34;Returns the variance of the distribution \( VAR[X] \).
    
    
        Returns
        -------
        float
            Variance of the distribution.
            
        &#34;&#34;&#34;                
        return np.sum(self.xk**2*self.pk)-self.mean()**2
    
    def std(self):
        r&#34;&#34;&#34;Returns the standard deviation of the distribution \( {STD}[X]=\sqrt{VAR[X]} \).
    
    
        Returns
        -------
        float
            Standard deviation of the distribution.
            
        &#34;&#34;&#34;                
        return math.sqrt(self.var())
    
    def cx(self):
        r&#34;&#34;&#34;Returns the coefficient of the variation of the distribution \( c_X = STD[X]/E[X] \).
    
    
        Returns
        -------
        float
            Coefficient of variation of the distribution.
            
        &#34;&#34;&#34;               
        return self.std()/self.mean()
    
    def mode(self):
        r&#34;&#34;&#34;Returns the mode of the distribution.
    
    
        Returns
        -------
        float
            Mode of the distribution.
            
        &#34;&#34;&#34;                
        return self.xk[np.argmax(self.pk)]
    
    def quantile(self, q=0.95):
        r&#34;&#34;&#34;Returns the q-quantile of the distribution.
    
        Parameters
        ----------
        q : float, optional (default 0.95)
            The parameter indicates that the q-quantile is derived. The default value is `q=0.95`
            for the 95%-quantile. It must be ensured that \( 0&lt; q &lt; 1\).
    
        Returns
        -------
        float
            q-Quantile (default 95%) of the distribution.
            
        &#34;&#34;&#34;                
        return self.xk[np.argmax(self.pk.cumsum()&gt;q)]
    
    def describe(self):
        r&#34;&#34;&#34;Prints basic characteristics of the distribution.        
        
        This method prints basic characteristics of the distribution.
        
        Example
        -------
        &gt;&gt;&gt; A.describe()
            interarrival_time: EX=5.5000, cX=0.5222, mode=1 
                        
        &#34;&#34;&#34;               
        print(f&#39;{self.name}: EX={self.mean():.4f}, cX={self.cx():.4f}, mode={self.mode()} &#39;)

    def checkDistribution(self):
        r&#34;&#34;&#34;Returns if the distribution is valid.         
    
        Returns
        -------
        bool
            Return true if the distribution is valid. 
            Returns false if e.g. the values of `xk` are not increasing or the sum of probabilities `pk` is less than 1.
            
        &#34;&#34;&#34;                
        increasing = np.all(np.diff(self.xk) &gt; 0) # xk: strictly monotonic increasing
        sumOne = abs(np.sum(self.pk)-1)&lt;1e-8 # xk: error
        return increasing and sumOne
            
    def conv(self, other,name=None):
        r&#34;&#34;&#34;Returns the sum of this distributions and another distribution.
        
        Returns the sum of this distribution and the other distribution. Note that \( A+B=B+A \).
        The operator `+` is overloaded for that class, such that `A+B` is an abbreviation for `A.conv(B)`.
        
        
        Parameters
        ----------
        other : DiscreteDistribution
            The other distribution of the sum.
        name : string, optional (default &#39;self.name+other.name&#39;)
            Name of the distribution for string representation.
            
        Example
        -------
        &gt;&gt;&gt; A = DU()
        &gt;&gt;&gt; A.conv(A) # returns A+A
        &gt;&gt;&gt; DiscreteDistribution.conv(A,A) # returns A+A
        &gt;&gt;&gt; A+A # returns A+A
    
        Returns
        -------
        DiscreteDistribution
            Sum of the distributions: `self+other`.
                    
        &#34;&#34;&#34;                
        s = f&#39;{self.name}+{other.name}&#39; if name is None else name     
        pk = np.convolve(self.pk, other.pk)
        xk = np.arange(self.xmin+other.xmin, self.xmax+other.xmax+1)
        return DiscreteDistribution(xk,pk,name=s)    
    
    def convNeg(self, other, name=None):
        r&#34;&#34;&#34;Returns the difference of two distributions.
        
        Returns the difference of this distribution and the other distribution. 
        The operator `-` is overloaded for that class, such that `A-B` is an abbreviation for `A.convNeg(B)`.
        
        
        Parameters
        ----------
        B : DiscreteDistribution
            The other distribution to be substracted from this distribution.
        name : string, optional (default &#39;A.name-B.name&#39;)
            Name of the distribution for string representation.
            
        Example
        -------
        &gt;&gt;&gt; A = DU()
        &gt;&gt;&gt; A.convNeg(A) # returns A-A
        &gt;&gt;&gt; DiscreteDistribution.convNeg(A,A) # returns A-A
        &gt;&gt;&gt; A-A # returns A-A
    
        Returns
        -------
        DiscreteDistribution
            Difference of the distributions: `self-other`.
                    
        &#34;&#34;&#34;
        s = f&#39;{self.name}-{other.name}&#39; if name is None else name     
        pk = np.convolve(self.pk, other.pk[::-1])
        xk = np.arange(self.xmin-other.xmax, self.xmax-other.xmin+1)
        return DiscreteDistribution(xk,pk,name=s)
        
    def pi_op(self, m=0, name=None):        
        r&#34;&#34;&#34;Applies the pi-operator (summing up probabilities to m) and returns the resulting distribution.
        
        The pi-operator truncates a distribution at the point \(X=m\) and sums up the probabilities. 
        The probability mass \( P(X\leq m) \) is assigned
        to the point \(X=m\), while all other probabilities are set to zero for \(X&lt;m\). The default operation is 
        to delete all negative values and assigning the probability mass of negative values to \(X=0\). 
        Hence, the default value is \(m=0\) and in this case \(P(X&#39;=0 ) = \sum_{i=-\infty}^0 P(X=i)\), while the probabilites for all negative values 
        are set to zero \(P(X&#39;= i ) = 0, \forall i&lt;0\) for the resulting distribution \(X&#39;\). The rest of the distribution \(i&gt;0 \) is not changed.
                                              
        In general: \(P(X&#39;=0 ) = \sum_{i=-\infty}^m P(X=i)\). Hence, for a distribution \(x(k)=P(X=k) \), 
        the pi-operator works as follows:

        $$
        \pi_m \Big(x(k)\Big)  =  \begin{cases}
                0 &amp; k &lt; m \\
                \sum\limits_{i = - \infty}^m
                   x(i) &amp; k= m \\
                x(k) &amp; k &gt; m \\
        \end{cases} 
        $$                              
        
        Parameters
        ----------
        m : integer
            The truncation point at which probabilities are summed up.
        name : string, optional (default &#39;pi_m(self.name)&#39;)
            Name of the distribution for string representation.
            
        Returns
        -------
        DiscreteDistribution
            Truncated distribution.
                    
        &#34;&#34;&#34;
        s = f&#39;pi_{m}({self.name})&#39; if name is None else name     
        if m &lt;= self.xmin:
            self.name = s
            return self
        elif m &gt;= self.xmax:
            return  DiscreteDistribution([m],[1],name=s)
        else:
            #s = f&#39;pi_{m}({A.name})&#39; if name is None else name        
            k = np.searchsorted(self.xk,m)
            xk = np.arange(m, self.xmax+1)
            pk = np.zeros(len(xk))
            pk[0] = np.sum(self.pk[0:k+1])
            pk[1:] = self.pk[k+1:]
            return DiscreteDistribution(xk,pk,name=s)
            
    def pi0(self, name=None):
        r&#34;&#34;&#34;Applies the pi-operator (truncation of negative values, summing up probabilities ) and returns the resulting distribution.
        
        The pi0-operator truncates the distribution at 0 and sums up the probabilities.  The probability mass of negative values is assigned to 0. 
        For the resulting distribution \(X&#39;\), it is \(P(X&#39;=0 ) = \sum_{i=-\infty}^0 P(X=i)\), while the probabilites for all negative values 
        are set to zero \(P(X&#39;= i ) = 0, \forall i&lt;0\). The rest of the distribution \(i&gt;0 \) is not changed.
                            
        $$
        \pi_0 \Big(x(k)\Big)  =  \begin{cases}
                0 &amp; k &lt; 0 \\
                \sum\limits_{i = - \infty}^0
                   x(i) &amp; k= 0 \\
                x(k) &amp; k &gt; 0 \\
        \end{cases} 
        $$
                                              
        Parameters
        ----------
        name : string, optional (default &#39;pi0(self.name)&#39;)
            Name of the distribution for string representation.
            
        Returns
        -------
        DiscreteDistribution
            Truncated distribution.

        See also
        -------
        Generalized truncation `DiscreteDistribution.pi_op`
        &#34;&#34;&#34;

        s = f&#39;pi0({self.name})&#39; if name is None else name
        return self.pi_op(m=0, name=s)
    
    def _trim(self, m, normalize=True):
        r&#34;&#34;&#34;Truncates the distribution from left and right side. 
        
        The operation uses the minimum and maximum of the values m and truncates the distribution to 
        this range. It changes the value range `xk` and the corresponding probabilities `pk`.

        Parameters
        ----------
        m : numpy array of boolean values
            The first and the last True value in the array are used to truncate the distribution.
        normalize : bool
            If True, the distribution is renormalized. If False, the distribution is truncated.
            
        Returns
        -------
        None
        &#34;&#34;&#34;                      
        kmin = m.argmax()
        kmax = m.size - m[::-1].argmax()-1
        
        #A.xmin = np.min(xk)
        #A.xmax = np.max(xk)        
        
        self.xk = self.xk[kmin:kmax+1]
        self.pk = self.pk[kmin:kmax+1]
        
        self.xmin = self.xk[0]
        self.xmax = self.xk[-1]
        
        if normalize:
            self.pk /= self.pk.sum()
        return
    
    def trim(self, normalize=True):
        r&#34;&#34;&#34;Remove trailing and leading diminishing probabilities. 
        
        The trim-operation changes the value range `xk` and the corresponding probabilities `pk` by removing
        any leading and any trailing diminishing probabilities. This distribution object is therefore changed.
        
        Parameters
        ----------        
        normalize : bool
            If True, the distribution is renormalized. If False, the distribution is truncated.

        Returns
        -------
        None
        &#34;&#34;&#34;                
        m = self.pk!=0        
        self._trim(m, normalize)
        return 
    
    def trimPMF(self, eps=1e-8, normalize=True):
        r&#34;&#34;&#34;Remove trailing and leading diminishing probabilities below a certain threshold. 
        
        The trimPMF-operation changes the value range `xk` and the corresponding probabilities `pk` by removing
        any leading and any trailing diminishing probabilities which are less than `eps`. 
        This distribution object is therefore changed.

        Parameters
        ----------
        eps : float
            Threshold which leading or trailing probabilities are to be removed.
        normalize : bool
            If True, the distribution is renormalized. If False, the distribution is truncated.
            
        Returns
        -------
        None        

        &#34;&#34;&#34;                
        m = self.pk&gt;eps #!=0        
        self._trim(m, normalize)
        return
    
    def trimCDF(self, eps=1e-8, normalize=True):
        r&#34;&#34;&#34;Remove trailing and leading diminishing cumulative probabilities below a certain threshold. 
        
        The trimCDF-operation changes the value range `xk` and the corresponding probabilities `pk` 
        by removing any leading and any trailing diminishing cumulative probabilities which are less than `eps`. 
        This distribution object is therefore changed.

        Parameters
        ----------
        eps : float
            Threshold which leading or trailing cumulative probabilities are to be removed.
        normalize : bool
            If True, the distribution is renormalized. If False, the distribution is truncated.
            
        Returns
        -------
        None        
        &#34;&#34;&#34;                
        m = self.pk.cumsum()&gt;eps #!=0        
        self._trim(m, normalize)
        return    
    
    
    # this is an unnormalized distribution: 
    # conditional distribution if normalized
    # sigmaLT = sigma^m: takes the lower part ( k &lt; m ) of a distribution
    def sigmaTakeLT(self, m=0, name=None, normalized=True):        
        r&#34;&#34;&#34;Applies the sigma-operator and returns the result.
        
        The sigma-operator returns the lower or the upper part of the distribution. 
        `sigmaTakeLT` implements the \(\sigma^m\)-operator which sweeps away the upper part \(k\geq m\) 
        and takes the lower part \(k &lt; m \). The distribution is therefore truncated. 
        The results of these operations are unnormalized distributions where the sum of the probabilities
        is less than one:
        $$\sigma^m[x(k)] = 
                \begin{cases}
                x(k) &amp; k&lt;m \\
                0 &amp; k \geq m 
        \end{cases}
        $$

        The parameter `normalized` (default True) indicates that a normalized distribution
        (conditional random variable) is returned, such that the sum of probabilities is one.
        The parameter `m` indicates at which point the distribution is truncated.
        
        Parameters
        ----------
        m : integer
            Truncation point. The lower part \(k &lt; m \) of the distribution is taken.        
        name : string, optional (default &#39;sigma^{m}({self.name})&#39;)
            Name of the distribution for string representation.
        normalized : bool
            If true returns a normalized distribution. If false the original probabilities for the 
            truncated range are returned. 
            
        Returns
        -------
        DiscreteDistribution
            Returns normalized or unnormalized truncated distribution taking probabilities for \(k &lt; m \).            

        Raises
        ------
        ValueError
            If m is less than the smallest value xmin of this distribution. 
            
        &#34;&#34;&#34;                
        #assert m&lt;xk[-1]
        s = f&#39;sigma^{m}({self.name})&#39; if name is None else name     
                
        if m&lt;=self.xk[0]:
            if normalized: 
                raise ValueError(&#39;sigmaLT: m &lt; min(xk)&#39;)
            else:
                return DiscreteDistribution([m], [0], name=s)
        if m&gt;self.xk[-1]:
            return DiscreteDistribution(self.xk, self.pk, name=s)
            
        last = np.searchsorted(self.xk, m, side=&#39;right&#39;)-1        
        
        xk=self.xk[:last]
        if normalized:
            prob_Dist_U_lt_m = self.pk[:last].sum() 
            pk=self.pk[:last] / prob_Dist_U_lt_m
        else:
            pk=self.pk[:last]                
        return DiscreteDistribution(xk, pk, name=s)
    
    # this is an unnormalized distribution: 
    # conditional distribution if normalized
    def sigmaTakeGEQ(self, m=0, name=None, normalized=True):
        r&#34;&#34;&#34;Applies the sigma-operator and returns the result.
        
        The sigma-operator returns the lower or the upper part of the distribution. 
        `sigmaTakeGEQ` implements the \(\sigma_m\)-operator which sweeps away the lower part \(k &lt; m \) 
        and takes the upper part \( k \geq m \). The distribution is therefore truncated. 
        The results of these operations are unnormalized distributions where the sum of the probabilities
        is less than one:
        $$    
        \sigma_m[x(k)] = 
                \begin{cases}
                0 &amp; k&lt;m \\
                x(k) &amp; k \geq m
                \end{cases} 
        $$

        The parameter `normalized` (default True) indicates that a normalized distribution
        (conditional random variable) is returned, such that the sum of probabilities is one.
        The parameter `m` indicates at which point the distribution is truncated.
        
        Parameters
        ----------
        m : integer
            Truncation point. The upper part \(k\geq m\) of the distribution is taken.        
        name : string, optional (default &#39;sigma_{m}({self.name})&#39;)
            Name of the distribution for string representation.
        normalized : bool
            If true returns a normalized distribution. If false the original probabilities for the 
            truncated range are returned. 
            
        Returns
        -------
        DiscreteDistribution
            Returns normalized or unnormalized truncated distribution taking probabilities for \(k \geq m \).

        &#34;&#34;&#34;
        s = f&#39;sigma_{m}({self.name})&#39; if name is None else name     
        #assert m&gt;=self.xk[0]
        if m&gt;self.xk[-1]:
            if normalized: 
                raise ValueError(&#39;sigmaGEQ: m &gt; max(xk)&#39;)
            else:
                return DiscreteDistribution([m], [0], name=s)                    
        
        first = np.searchsorted(self.xk, m, side=&#39;left&#39;)
        
        xk=self.xk[first:]
        if normalized:
            prob_Dist_U_geq_m = self.pk[first:].sum() 
            pk=self.pk[first:] / prob_Dist_U_geq_m
        else:
            pk=self.pk[first:]                
        return DiscreteDistribution(xk, pk, name=s)
    
    def pmf(self, xi):
        r&#34;&#34;&#34;Probability mass function at xi of the given distribution.

        Parameters
        ----------
        xi : numpy array or integer
            Quantiles.
            
        Returns
        -------
        numpy array of float
            Probability mass function evaluated at xi.
        &#34;&#34;&#34;                
        #myxk = np.arange(self.xmin-1, self.xmax+2)
        #mypk = np.hstack((0, self.pk, 0))
        if type(xi) is not np.ndarray:
            if type(xi) is list:
                xi = np.array(xi)
            else:
                xi = np.array([xi])
        
        i = np.where( (xi&gt;=self.xmin) &amp; (xi&lt;=self.xmax) )[0]
        mypk = np.zeros(len(xi))
        
        if len(i)&gt;0:            
            mypk[i] = self.pk[np.searchsorted(self.xk, xi[i], side=&#39;left&#39;)]
        return mypk
    
    def cdf(self, xi):
        r&#34;&#34;&#34;Cumulative distribution function at xi of the given distribution.

        Parameters
        ----------
        xi : numpy array or integer
            Quantiles.
            
        Returns
        -------
        numpy array of float
            Cumulative distribution function evaluated at xi.
        &#34;&#34;&#34;                
        #myxk = np.arange(self.xmin-1, self.xmax+2)
        #mypk = np.hstack((0, self.pk, 0))
        PK = self.pk.cumsum()
        if type(xi) is not np.ndarray:
            if type(xi) is list:
                xi = np.array(xi)
            else:
                xi = np.array([xi])
        
        i = np.where( (xi&gt;=self.xmin) &amp; (xi&lt;=self.xmax) )[0]
        mypk = np.zeros(len(xi))
        
        if len(i)&gt;0:            
            mypk[i] = PK[np.searchsorted(self.xk, xi[i], side=&#39;left&#39;)]
        return mypk
    
    def plotCDF(self,  addZero=True, **kwargs):
        r&#34;&#34;&#34;Plots the cumulative distribution function of this distrribution.

        Parameters
        ----------
        addZero : bool (default True)
            If true the zero point will be explicitly plotted, otherwise not.
        **kwargs: 
            Arbitrary keyword arguments are passed to `Matplotlib.pyplot.step`.
            
        Returns
        -------
        None
        &#34;&#34;&#34;                
        if addZero and self.xk[0]&gt;=0:
            x = np.insert(self.xk,0,0)
            y = np.insert(self.pk,0,0)
        else:
            x, y = self.xk, self.pk
        
        x = np.append(x, x[-1]+1)
        Y = np.append(y.cumsum(), 1)
        
        plt.step(x, Y, &#39;.-&#39;, where=&#39;post&#39;, **kwargs)
        
    def plotPMF(self,  **kwargs):
        r&#34;&#34;&#34;Plots the probability mass function of this distrribution.

        Parameters
        ----------        
        **kwargs: 
            Arbitrary keyword arguments are passed to `Matplotlib.pyplot.plot`.
            
        Returns
        -------
        None
        &#34;&#34;&#34;                
        plt.plot(self.xk, self.pk, &#39;.-&#39;, **kwargs)        
        
    def conditionalRV(self, condition, name=None, normalized=True):
        r&#34;&#34;&#34;Returns the normalized or unnormalized conditional random variable.

        Parameters
        ----------
        condition : function
            Applies the function `condition` to match the corresponding values of the distribution.        
        name : string, optional (default &#39;{self.name}&#39;)
            Name of the distribution for string representation.
        normalized : bool (default True)
            If true returns a normalized distribution. If false returns the original probabilities for the 
            range where the condition is true. 
            
        Returns
        -------
        DiscreteDistribution
            Returns the conditional distribution for which the condition (applied to `xk`) is true. 
            The resulting distribution is normalized if the paraemter `normalized` is true.
            
            
        Raises
        ------
        ValueError
            If the condition is not fulfilled for any value `xk`
            
        &#34;&#34;&#34;     
        s = f&#39;{self.name}|condition&#39; if name is None else name     
        which = condition(self.xk)
        
        Apk = self.pk[which] 
        Axk = self.xk[which] 
        if normalized:            
            if Apk.sum()==0:
                raise ValueError(&#39;conditionalRV: condition is not possible!&#39;)
            return DiscreteDistribution(Axk, Apk/Apk.sum(), name=s)   
        else:
            return DiscreteDistribution(Axk, Apk, name=s)   
        
    
    # A+B
    def __add__(self, other):                
        return DiscreteDistribution.conv(self,other,name=f&#39;{self.name}+{other.name}&#39;)
    
    # A-C
    def __sub__(self, other):                 
        return DiscreteDistribution.convNeg(self,other,name=f&#39;{self.name}-{other.name}&#39;)
    
    # A-C
    def __mul__(A, B):                 
        if isinstance(A,DiscreteDistribution):
            return DiscreteDistribution(A.xk*B,A.pk,name=f&#39;{B}*{A.name}&#39;)
        elif isinstance(B,DiscreteDistribution):
            return DiscreteDistribution(B.xk*A,B.pk,name=f&#39;{A}*{B.name}&#39;)
            
    # A&lt;B: based on means
    def __lt__(self, other):                        
        return self.mean() &lt; other.mean()
    
    # A&lt;=B: based on means
    def __le__(self, other):                        
        return self.mean() &lt;= other.mean()
    
    # A&gt;B: based on means
    def __gt__(self, other):                        
        return self.mean() &gt; other.mean()
    
    # A&gt;=B: based on means
    def __ge__(self, other):                        
        return self.mean() &gt;= other.mean()
    
    # A==B: based on means and threshold comparisonEQ_eps
    def __eq__(self, other):                        
        #if len(self.xk) != len(other.xk): return False
        #return np.all(self.xk==other.xk) and np.all(self.pk==other.pk)
        return abs(self.mean()-other.mean())&lt;=comparisonEQ_eps
    
    # A!=B: based on means and threshold comparisonEQ_eps
    def __ne__(self, other):                        
        return abs(self.mean()-other.mean())&gt;comparisonEQ_eps
    
    def __getExtendedRangeDist(self, xmin, xmax):
        end = np.zeros(xmax-self.xmax) if self.xmax &lt; xmax else []
        start = np.zeros(self.xmin-xmin) if self.xmin &gt; xmin else []    
        return np.concatenate((start, self.pk, end))
        
        
    # A|condition
    def __or__(self, other):
        if callable(other):  # A|condition
            return self.conditionalRV(other)
    
    def __repr__(self):                
        return self.__str__()

    def __str__(self):
        if len(self.xk)&lt;10:
            return f&#39;{self.name}: xk={np.array2string(self.xk,separator=&#34;,&#34;)}, pk={np.array2string(self.pk,precision=3, separator=&#34;,&#34;)}&#39;
        else:
            return f&#39;{self.name}: xk={self.xmin},...,{self.xmax}, pk={self.pk[0]:g},...,{self.pk[-1]:g}&#39;



#%%    
def pi_op(A, m=0, name=None):    
    r&#34;&#34;&#34;Returns the pi-operator applied to A.
    
    See also
    ----------
    `DiscreteDistribution.pi_op`
    &#34;&#34;&#34; 
    return A.pi_op(m, name)

        
def max(A, m, name=None):    
    r&#34;&#34;&#34;Returns the pi-operator applied to the distribution A.
    
    The pi-operator means the maximum of this random variable and the value m. 
    The following two expressions are identical: `max(A,0)` and `pi_op(A,m)`.
    
    See also
    ----------
    `DiscreteDistribution.pi_op`
    &#34;&#34;&#34; 
    return A.pi_op(m, name)

def pi0(A, name=None):
    r&#34;&#34;&#34;Returns the pi0-operator applied to A.
    
    See also
    ----------
    `DiscreteDistribution.pi0`
    &#34;&#34;&#34; 
    return A.pi0(name=name)    

def conv(A,B,name=None):
    r&#34;&#34;&#34;Returns the sum of the random variables A+B using convolution operator.
    
    See also
    ----------
    `DiscreteDistribution.conv`
    &#34;&#34;&#34;        
    return A.conv(B, name=name)


def plotCDF(A, addZero=True, **kwargs):
    r&#34;&#34;&#34;Plots the CDF of the distribution `A`. 
    
    See also
    ----------
    `DiscreteDistribution.plotCDF`
    &#34;&#34;&#34;      
    A.plotCDF(addZero, **kwargs)
    
def plotPMF(A, addZero=True, **kwargs):
    r&#34;&#34;&#34;Plots the PMF of the distribution `A`. 
    
    See also
    ----------
    `DiscreteDistribution.plotPMF`
    &#34;&#34;&#34;      
    A.plotPMF(addZero, **kwargs)    
    

def lindley_equation(W0, C, epsProb=1e-16):
    r&#34;&#34;&#34;Implements the Lindley equation.

    Solves the discrete-time Lindley equation which is used for the analysis of the waiting time
    in a GI/GI/1 system. 
    
    $$
    w(k)  =   \pi_0 \Big(w(k) * c(k)\Big) 
    $$
    
    The solution is derived by iteration for a given starting distribution `W0` until the difference \(W_{n+1}-W_{n} \) between
    subsequent distributions is below the treshold `discreteTimeAnalysis.comparisonEQ_eps`.
    
    $$ 
    W_{n+1} = \max(0, W_n+B-A) \\
    w_{n+1} (k)  =  \pi_0  (w_n(k) * c_n(k)) 
    $$

    Parameters
    ----------
    W0 : DiscreteDistribution
        The initial system distribution.
    C : DiscreteDistribution
        The characteristic function of the system.
    eps : float (default 1e-16)
        Threshold which leading or trailing probabilities are to be removed. See `DiscreteDistribution.trimPMF`.  

    Returns
    -------
    DiscreteDistribution
        Steady-state distribution of the stationary discrete-time Lindley equation.
    &#34;&#34;&#34;         
    Wn = W0
    Wn1 = DiscreteDistribution([-1], [1])
    i = 0
    
    while Wn1 != Wn:
        Wn1 = pi0(Wn+C)
        
        Wn = Wn1
        Wn.name = None
        Wn.trimPMF(eps=epsProb)
        i += 1
    return Wn, i


def GIGI1_waitingTime(A, B, W0=DiscreteDistribution([0],[1]), epsProb=1e-16):  
    r&#34;&#34;&#34;Returns the stationary waiting time distribution of the GI/GI/1 queue.

    The stationary waiting time distribution of the GI/GI/1 queue is derived by solving
    the Lindley equation, see `discreteTimeAnalysis.lindley_equation`.

    Parameters
    ----------
    W0 : DiscreteDistribution, optional (default DET(0))
        The initial waiting time distribution. The default value is an empty system, i.e. no waiting time 
        `W0 = DET(0)`.
    A : DiscreteDistribution
        Interarrival time.
    B : DiscreteDistribution
        Service time.
    eps : float (default 1e-16)
        Threshold which leading or trailing probabilities are to be removed. See `DiscreteDistribution.trimPMF`.  

    Returns
    -------
    DiscreteDistribution
        Steady-state waiting time distribution of the GI/GI/1 queue.
        
    Raises
    -------
    ValueError
        If the system utilization EB/EA&gt;1.
        
    See also
    --------
    `discreteTimeAnalysis.lindley_equation`
    &#34;&#34;&#34; 
    if B.mean()/A.mean() &gt;= 1:
        raise ValueError(f&#39;GIGI1_waitingTime: System utilization is rho={B.mean()/A.mean():.2f}&gt;1&#39;)     
    return lindley_equation(W0, B-A, epsProb)
    
def kingman(EA, cA, EB, cB):
    r&#34;&#34;&#34;Returns the Kingman approximation for the mean waiting time of a GI/GI/1 queue.

    Parameters
    ----------
    EA : float
        Mean interarrival time.
    cA : float
        Coefficient of variation of the interarrival time.
    EB : float
        Mean service time.
    cB : float
        Coefficient of variation of the service time.

    Returns
    -------
    float
        Kingman approximation of the mean waiting time.
        
    Raises
    -------
    ValueError
        If the system utilization EB/EA&gt;1.
    &#34;&#34;&#34;     
    rho = EB/EA
    raise ValueError(f&#39;Kingman: System utilization is rho={rho:.2f}&gt;1&#39;)
    return rho/(1-rho)*EB*(cA**2+cB**2)/2

#%% Bernoulli distribution
def BER(p, name=None):
    r&#34;&#34;&#34;Returns a Bernoulli distribution.
    
    With the success probability p, the Bernoulli experiment is sucessful.
    \(P(X=1)=p\) and \(P(X=0)=1-p\).

    Parameters
    ----------
    p : float
        Sucess probability.
    name : string, optional (default &#39;BER(p)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a Bernoulli distribution with success probability p.
        
    Raises
    -------
    ValueError
        If the success probability is not in the range 0&lt;p&lt;1. 
    &#34;&#34;&#34;         
    if p&gt;1 or p&lt;0:
        raise ValueError(f&#39;BER: success probability {p:.2f} out of range&#39;)
    s = f&#39;BER({p:.2f})&#39; if name is None else name
    return DiscreteDistribution([0,1],[1-p,p], name=s)

from scipy.stats import binom
# Binomial distribution
def BINOM(N, p, name=None):
    r&#34;&#34;&#34;Returns a Binomial distribution.
    
    The binomial distribution counts the number of successes, if 
    a Bernoulli experiment is repeated N-times with success probability p.
    
    Parameters
    ----------
    N : integer
        Number of Bernoulli experiments.
    p : float
        Sucess probability.
    name : string, optional (default &#39;BINOM(N,p)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a Binomial distribution with parameters N and p.
        
    Raises
    -------
    ValueError
        If the success probability is not in the range 0&lt;p&lt;1. 
    &#34;&#34;&#34;         
    if p&gt;1 or p&lt;0:
        raise ValueError(f&#39;BINOM: success probability {p:.2f} out of range&#39;)
    s = f&#39;BINOM({N}, {p:.2f})&#39; if name is None else name
    xk = np.arange(N+1)
    return DiscreteDistribution(xk, binom.pmf(xk, N, p), name=s)

from scipy.stats import poisson
# poisson distribution
def POIS(y, eps=1e-8, name=None):
    r&#34;&#34;&#34;Returns a Poisson distribution with mean y.
    
    The Poisson distribution is a discrete distribution and has a single parameter 
    reflecting the mean of the random variable. Since the DiscreteDistribution needs to 
    have a finite range, the distribution is truncated at the right side if the probabilities
    are less than `eps`.
    
    Parameters
    ----------
    y : float
        Mean of the Poisson distribution.
    eps : float, optional (default 1e-8)
        Threshold value where to truncate the right part of the CDF.
    name : string, optional (default &#39;POIS(y)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a Poisson distribution with parameter y.
        
    Raises
    -------
    ValueError
        If the mean value is negative.
    &#34;&#34;&#34;   
    if y&lt;0:
        raise ValueError(f&#39;POIS: mean value {y:.2f} out of range&#39;)
    
    s = f&#39;POIS({y:.2f})&#39; if name is None else name
    
    rv = poisson(y)
    cut = int(rv.isf(eps))
    #print(f&#39;cut at {cut}&#39;)
    x = np.arange(cut)
    pk = rv.pmf(x)
    return DiscreteDistribution(x, pk/pk.sum(), name=s)

#%% NEGBIN files
from scipy.stats import nbinom, geom

def getNegBinPars(mu,cx):
    r&#34;&#34;&#34;Returns the two parameters of a negative binomial distribution for given mean and coefficient of variation.

    Parameters
    ----------
    mu : float
        Mean value.
    cx : float
        Coefficient of variation.

    Returns
    -------
    a,b : float, float
        Parameters of the negative binomial distribution.
        
    Raises
    -------
    ValueError
        If the parameter range is violated: mu*cx**2&gt;1
    &#34;&#34;&#34;     
    if mu*cx**2&lt;=1:
        raise ValueError(f&#39;getNegBinPars: parameter range is not possible, mu*cx**2={mu*cx**2:2.f}&lt;=1 &#39;)    
    z = cx**2*mu-1    
    return mu/z, 1- z/(cx**2*mu)


def NEGBIN(EX,cx, eps=1e-8, name=None):
    r&#34;&#34;&#34;Returns a negative binomial distribution for given mean and coefficient of variation.

    Parameters
    ----------
    mu : float
        Mean value.
    cx : float
        Coefficient of variation.
    eps : float, optional (default 1e-8)
        Threshold value where to truncate the right part of the CDF.
    name : string, optional (default &#39;NEGBIN(EX,cx)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a negative binomial distribution with mean EX and coefficient of variation cx.
        
    Raises
    -------
    ValueError
        If the parameter range is violated: mu*cx**2&gt;1
    &#34;&#34;&#34;     
    r,p = getNegBinPars(EX,cx)
    
    s = f&#39;NEGBIN({EX:.2f},{cx:.2f})&#39; if name is None else name
    
    rv = nbinom(r,p)
    cut = int(rv.isf(eps))
    #print(f&#39;cut at {cut}&#39;)
    x = np.arange(cut)
    pk = rv.pmf(x)
    return DiscreteDistribution(x, pk/pk.sum(), name=s)

def DET(EX, name=None):
    r&#34;&#34;&#34;Returns a deterministic distribution.

    With probability 1, the distribution takes the value EX.

    Parameters
    ----------
    EX : integer
        Mean value.    
    name : string, optional (default &#39;DET(EX)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a deterministic distribution with parameter EX.        
    &#34;&#34;&#34;     
    return DiscreteDistribution([EX], [1.0], name=name)
    
def DU(a=1, b=10, name=None):    
    r&#34;&#34;&#34;Returns a discrete uniform distribution in the range [a,b].

    With the same probability, any value a &lt;= k &lt;=b is taken. 

    Parameters
    ----------
    a : integer
        Lower value range.    
    b : integer
        Upper value range.    
    name : string, optional (default &#39;DU(a,b)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a discrete uniform distribution in the interval [a;b].        
    &#34;&#34;&#34;    
    s = f&#39;DET({a},{b})&#39; if name is None else name
    
    xk = np.arange(a,b+1)
    n = b-a+1
    pk = 1.0/n
    return DiscreteDistribution(xk, np.array([pk]*n), name=s)    

def GEOM(EX, m=0, eps=1e-8, name=None):
    r&#34;&#34;&#34;Returns a shifted geometric distribution with mean EX.

    A shifted geometric distribution is returned which has the mean value `EX`. 
    The distribution is thereby shifted by `m`. Thus, \(P(X=k=0\) for any \(k&lt;m\).
    
    Parameters
    ----------
    EX : float
        Mean value of the shifted geometric distribution.
    m : integer (default 0)
        Distribution is shifted by m.    
    eps : float, optional (default 1e-8)
        Threshold value where to truncate the right part of the CDF.
    name : string, optional (default &#39;GEOM_m(p)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a shifted geometric distribution with mean EX.        
    &#34;&#34;&#34;        
    p = 1.0/(EX+1-m)    
    rv = geom(p, loc=m-1)
    cut = int(rv.isf(eps))    
    x = np.arange(cut)
    pk = rv.pmf(x)
    
    s = f&#39;GEOM_{m}({p:.2f})&#39; if name is None else name   
    return DiscreteDistribution(x, pk/pk.sum(), name=s)


#%% mixture distribution
def MIX(A, w=None, name=None):
    r&#34;&#34;&#34;Returns the mixture distribution with weights w.

    Consider a set of independent random variables [A_1,..,A_k].
    A random variable $A$ is now constructed in such a way that with the probability p_i the random variable A_i is selected. 
    
    Parameters
    ----------
    A : list of DiscreteDistributions
        List of distributions. 
    w : list of weights, optional (default w=[1/k, ..., 1/k])
        A distribution is considered with the probabilities given in the list of weights.
    name : string, optional (default &#39;MIX&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a shifted geometric distribution with mean EX.        
        
    Example
    -------
    &gt;&gt;&gt; A = DET(4)
    &gt;&gt;&gt; B = DU(1,10)
    &gt;&gt;&gt; C = MIX( (A,B) )
    &gt;&gt;&gt; D = A+B

    &gt;&gt;&gt; plt.figure(1, clear=True)
    &gt;&gt;&gt; A.plotCDF(label=&#39;A&#39;)
    &gt;&gt;&gt; B.plotCDF(label=&#39;B&#39;)
    &gt;&gt;&gt; C.plotCDF(label=&#39;MIX&#39;)
    &gt;&gt;&gt; D.plotCDF(label=&#39;A+B&#39;)
    &gt;&gt;&gt; plt.legend()
    &#34;&#34;&#34;     
    xkMin = min(list(map(lambda Ai: Ai.xk[0], A)))
    xkMax = max(list(map(lambda Ai: Ai.xk[-1], A)))
    
    if w is None:
        n = len(A)
        w = [1.0/n]*n
    
    xk = np.arange( xkMin, xkMax+1)
    pk = np.zeros(len(xk))
    for (Ai, wi) in zip(A,w):
        iA = np.searchsorted(xk, Ai.xk, side=&#39;left&#39;)
        pk[iA] += Ai.pk*wi
    s = &#39;MIX&#39; if name is None else name   
    return DiscreteDistribution(xk, pk, name=s)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="discreteTimeAnalysis.comparisonEQ_eps"><code class="name">var <span class="ident">comparisonEQ_eps</span></code></dt>
<dd>
<div class="desc"><p>The variable is used for the numerical comparison of two random variables <code>A</code>and <code>B</code>.
The comparison <code>A==B</code> returns true if <code>abs( A.mean() - B.mean() ) &lt;= comparisonEQ_eps</code>.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="discreteTimeAnalysis.BER"><code class="name flex">
<span>def <span class="ident">BER</span></span>(<span>p, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a Bernoulli distribution.</p>
<p>With the success probability p, the Bernoulli experiment is sucessful.
<span><span class="MathJax_Preview">P(X=1)=p</span><script type="math/tex">P(X=1)=p</script></span> and <span><span class="MathJax_Preview">P(X=0)=1-p</span><script type="math/tex">P(X=0)=1-p</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>Sucess probability.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'BER(p)')</code></dt>
<dd>Name of the distribution for string representation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Returns a Bernoulli distribution with success probability p.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the success probability is not in the range 0&lt;p&lt;1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BER(p, name=None):
    r&#34;&#34;&#34;Returns a Bernoulli distribution.
    
    With the success probability p, the Bernoulli experiment is sucessful.
    \(P(X=1)=p\) and \(P(X=0)=1-p\).

    Parameters
    ----------
    p : float
        Sucess probability.
    name : string, optional (default &#39;BER(p)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a Bernoulli distribution with success probability p.
        
    Raises
    -------
    ValueError
        If the success probability is not in the range 0&lt;p&lt;1. 
    &#34;&#34;&#34;         
    if p&gt;1 or p&lt;0:
        raise ValueError(f&#39;BER: success probability {p:.2f} out of range&#39;)
    s = f&#39;BER({p:.2f})&#39; if name is None else name
    return DiscreteDistribution([0,1],[1-p,p], name=s)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.BINOM"><code class="name flex">
<span>def <span class="ident">BINOM</span></span>(<span>N, p, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a Binomial distribution.</p>
<p>The binomial distribution counts the number of successes, if
a Bernoulli experiment is repeated N-times with success probability p.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>integer</code></dt>
<dd>Number of Bernoulli experiments.</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>Sucess probability.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'BINOM(N,p)')</code></dt>
<dd>Name of the distribution for string representation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Returns a Binomial distribution with parameters N and p.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the success probability is not in the range 0&lt;p&lt;1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BINOM(N, p, name=None):
    r&#34;&#34;&#34;Returns a Binomial distribution.
    
    The binomial distribution counts the number of successes, if 
    a Bernoulli experiment is repeated N-times with success probability p.
    
    Parameters
    ----------
    N : integer
        Number of Bernoulli experiments.
    p : float
        Sucess probability.
    name : string, optional (default &#39;BINOM(N,p)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a Binomial distribution with parameters N and p.
        
    Raises
    -------
    ValueError
        If the success probability is not in the range 0&lt;p&lt;1. 
    &#34;&#34;&#34;         
    if p&gt;1 or p&lt;0:
        raise ValueError(f&#39;BINOM: success probability {p:.2f} out of range&#39;)
    s = f&#39;BINOM({N}, {p:.2f})&#39; if name is None else name
    xk = np.arange(N+1)
    return DiscreteDistribution(xk, binom.pmf(xk, N, p), name=s)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DET"><code class="name flex">
<span>def <span class="ident">DET</span></span>(<span>EX, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a deterministic distribution.</p>
<p>With probability 1, the distribution takes the value EX.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>EX</code></strong> :&ensp;<code>integer</code></dt>
<dd>Mean value.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'DET(EX)')</code></dt>
<dd>Name of the distribution for string representation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Returns a deterministic distribution with parameter EX.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DET(EX, name=None):
    r&#34;&#34;&#34;Returns a deterministic distribution.

    With probability 1, the distribution takes the value EX.

    Parameters
    ----------
    EX : integer
        Mean value.    
    name : string, optional (default &#39;DET(EX)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a deterministic distribution with parameter EX.        
    &#34;&#34;&#34;     
    return DiscreteDistribution([EX], [1.0], name=name)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DU"><code class="name flex">
<span>def <span class="ident">DU</span></span>(<span>a=1, b=10, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a discrete uniform distribution in the range [a,b].</p>
<p>With the same probability, any value a &lt;= k &lt;=b is taken. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>integer</code></dt>
<dd>Lower value range.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>integer</code></dt>
<dd>Upper value range.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'DU(a,b)')</code></dt>
<dd>Name of the distribution for string representation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Returns a discrete uniform distribution in the interval [a;b].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DU(a=1, b=10, name=None):    
    r&#34;&#34;&#34;Returns a discrete uniform distribution in the range [a,b].

    With the same probability, any value a &lt;= k &lt;=b is taken. 

    Parameters
    ----------
    a : integer
        Lower value range.    
    b : integer
        Upper value range.    
    name : string, optional (default &#39;DU(a,b)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a discrete uniform distribution in the interval [a;b].        
    &#34;&#34;&#34;    
    s = f&#39;DET({a},{b})&#39; if name is None else name
    
    xk = np.arange(a,b+1)
    n = b-a+1
    pk = 1.0/n
    return DiscreteDistribution(xk, np.array([pk]*n), name=s)    </code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.GEOM"><code class="name flex">
<span>def <span class="ident">GEOM</span></span>(<span>EX, m=0, eps=1e-08, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a shifted geometric distribution with mean EX.</p>
<p>A shifted geometric distribution is returned which has the mean value <code>EX</code>.
The distribution is thereby shifted by <code>m</code>. Thus, <span><span class="MathJax_Preview">P(X=k=0</span><script type="math/tex">P(X=k=0</script></span> for any <span><span class="MathJax_Preview">k&lt;m</span><script type="math/tex">k<m</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>EX</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean value of the shifted geometric distribution.</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>integer (default 0)</code></dt>
<dd>Distribution is shifted by m.</dd>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code>, optional <code>(default 1e-8)</code></dt>
<dd>Threshold value where to truncate the right part of the CDF.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'GEOM_m(p)')</code></dt>
<dd>Name of the distribution for string representation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Returns a shifted geometric distribution with mean EX.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GEOM(EX, m=0, eps=1e-8, name=None):
    r&#34;&#34;&#34;Returns a shifted geometric distribution with mean EX.

    A shifted geometric distribution is returned which has the mean value `EX`. 
    The distribution is thereby shifted by `m`. Thus, \(P(X=k=0\) for any \(k&lt;m\).
    
    Parameters
    ----------
    EX : float
        Mean value of the shifted geometric distribution.
    m : integer (default 0)
        Distribution is shifted by m.    
    eps : float, optional (default 1e-8)
        Threshold value where to truncate the right part of the CDF.
    name : string, optional (default &#39;GEOM_m(p)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a shifted geometric distribution with mean EX.        
    &#34;&#34;&#34;        
    p = 1.0/(EX+1-m)    
    rv = geom(p, loc=m-1)
    cut = int(rv.isf(eps))    
    x = np.arange(cut)
    pk = rv.pmf(x)
    
    s = f&#39;GEOM_{m}({p:.2f})&#39; if name is None else name   
    return DiscreteDistribution(x, pk/pk.sum(), name=s)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.GIGI1_waitingTime"><code class="name flex">
<span>def <span class="ident">GIGI1_waitingTime</span></span>(<span>A, B, W0=discrete distr.: xk=[0], pk=[1.], epsProb=1e-16)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stationary waiting time distribution of the GI/GI/1 queue.</p>
<p>The stationary waiting time distribution of the GI/GI/1 queue is derived by solving
the Lindley equation, see <code><a title="discreteTimeAnalysis.lindley_equation" href="#discreteTimeAnalysis.lindley_equation">lindley_equation()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>W0</code></strong> :&ensp;<code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code>, optional <code>(default <a title="discreteTimeAnalysis.DET" href="#discreteTimeAnalysis.DET">DET()</a>(0))</code></dt>
<dd>The initial waiting time distribution. The default value is an empty system, i.e. no waiting time
<code>W0 = DET(0)</code>.</dd>
<dt><strong><code>A</code></strong> :&ensp;<code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Interarrival time.</dd>
<dt><strong><code>B</code></strong> :&ensp;<code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Service time.</dd>
<dt><strong><code>eps</code></strong> :&ensp;<code>float (default 1e-16)</code></dt>
<dd>Threshold which leading or trailing probabilities are to be removed. See <code><a title="discreteTimeAnalysis.DiscreteDistribution.trimPMF" href="#discreteTimeAnalysis.DiscreteDistribution.trimPMF">DiscreteDistribution.trimPMF()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Steady-state waiting time distribution of the GI/GI/1 queue.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the system utilization EB/EA&gt;1.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="discreteTimeAnalysis.lindley_equation" href="#discreteTimeAnalysis.lindley_equation">lindley_equation()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GIGI1_waitingTime(A, B, W0=DiscreteDistribution([0],[1]), epsProb=1e-16):  
    r&#34;&#34;&#34;Returns the stationary waiting time distribution of the GI/GI/1 queue.

    The stationary waiting time distribution of the GI/GI/1 queue is derived by solving
    the Lindley equation, see `discreteTimeAnalysis.lindley_equation`.

    Parameters
    ----------
    W0 : DiscreteDistribution, optional (default DET(0))
        The initial waiting time distribution. The default value is an empty system, i.e. no waiting time 
        `W0 = DET(0)`.
    A : DiscreteDistribution
        Interarrival time.
    B : DiscreteDistribution
        Service time.
    eps : float (default 1e-16)
        Threshold which leading or trailing probabilities are to be removed. See `DiscreteDistribution.trimPMF`.  

    Returns
    -------
    DiscreteDistribution
        Steady-state waiting time distribution of the GI/GI/1 queue.
        
    Raises
    -------
    ValueError
        If the system utilization EB/EA&gt;1.
        
    See also
    --------
    `discreteTimeAnalysis.lindley_equation`
    &#34;&#34;&#34; 
    if B.mean()/A.mean() &gt;= 1:
        raise ValueError(f&#39;GIGI1_waitingTime: System utilization is rho={B.mean()/A.mean():.2f}&gt;1&#39;)     
    return lindley_equation(W0, B-A, epsProb)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.MIX"><code class="name flex">
<span>def <span class="ident">MIX</span></span>(<span>A, w=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the mixture distribution with weights w.</p>
<p>Consider a set of independent random variables [A_1,..,A_k].
A random variable $A$ is now constructed in such a way that with the probability p_i the random variable A_i is selected. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>A</code></strong> :&ensp;<code>list</code> of <code>DiscreteDistributions</code></dt>
<dd>List of distributions.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>list</code> of <code>weights</code>, optional <code>(default w=[1/k, ..., 1/k])</code></dt>
<dd>A distribution is considered with the probabilities given in the list of weights.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'MIX')</code></dt>
<dd>Name of the distribution for string representation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Returns a shifted geometric distribution with mean EX.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; A = DET(4)
&gt;&gt;&gt; B = DU(1,10)
&gt;&gt;&gt; C = MIX( (A,B) )
&gt;&gt;&gt; D = A+B
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; plt.figure(1, clear=True)
&gt;&gt;&gt; A.plotCDF(label='A')
&gt;&gt;&gt; B.plotCDF(label='B')
&gt;&gt;&gt; C.plotCDF(label='MIX')
&gt;&gt;&gt; D.plotCDF(label='A+B')
&gt;&gt;&gt; plt.legend()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MIX(A, w=None, name=None):
    r&#34;&#34;&#34;Returns the mixture distribution with weights w.

    Consider a set of independent random variables [A_1,..,A_k].
    A random variable $A$ is now constructed in such a way that with the probability p_i the random variable A_i is selected. 
    
    Parameters
    ----------
    A : list of DiscreteDistributions
        List of distributions. 
    w : list of weights, optional (default w=[1/k, ..., 1/k])
        A distribution is considered with the probabilities given in the list of weights.
    name : string, optional (default &#39;MIX&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a shifted geometric distribution with mean EX.        
        
    Example
    -------
    &gt;&gt;&gt; A = DET(4)
    &gt;&gt;&gt; B = DU(1,10)
    &gt;&gt;&gt; C = MIX( (A,B) )
    &gt;&gt;&gt; D = A+B

    &gt;&gt;&gt; plt.figure(1, clear=True)
    &gt;&gt;&gt; A.plotCDF(label=&#39;A&#39;)
    &gt;&gt;&gt; B.plotCDF(label=&#39;B&#39;)
    &gt;&gt;&gt; C.plotCDF(label=&#39;MIX&#39;)
    &gt;&gt;&gt; D.plotCDF(label=&#39;A+B&#39;)
    &gt;&gt;&gt; plt.legend()
    &#34;&#34;&#34;     
    xkMin = min(list(map(lambda Ai: Ai.xk[0], A)))
    xkMax = max(list(map(lambda Ai: Ai.xk[-1], A)))
    
    if w is None:
        n = len(A)
        w = [1.0/n]*n
    
    xk = np.arange( xkMin, xkMax+1)
    pk = np.zeros(len(xk))
    for (Ai, wi) in zip(A,w):
        iA = np.searchsorted(xk, Ai.xk, side=&#39;left&#39;)
        pk[iA] += Ai.pk*wi
    s = &#39;MIX&#39; if name is None else name   
    return DiscreteDistribution(xk, pk, name=s)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.NEGBIN"><code class="name flex">
<span>def <span class="ident">NEGBIN</span></span>(<span>EX, cx, eps=1e-08, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a negative binomial distribution for given mean and coefficient of variation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mu</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean value.</dd>
<dt><strong><code>cx</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient of variation.</dd>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code>, optional <code>(default 1e-8)</code></dt>
<dd>Threshold value where to truncate the right part of the CDF.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'NEGBIN(EX,cx)')</code></dt>
<dd>Name of the distribution for string representation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Returns a negative binomial distribution with mean EX and coefficient of variation cx.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the parameter range is violated: mu<em>cx</em>*2&gt;1</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NEGBIN(EX,cx, eps=1e-8, name=None):
    r&#34;&#34;&#34;Returns a negative binomial distribution for given mean and coefficient of variation.

    Parameters
    ----------
    mu : float
        Mean value.
    cx : float
        Coefficient of variation.
    eps : float, optional (default 1e-8)
        Threshold value where to truncate the right part of the CDF.
    name : string, optional (default &#39;NEGBIN(EX,cx)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a negative binomial distribution with mean EX and coefficient of variation cx.
        
    Raises
    -------
    ValueError
        If the parameter range is violated: mu*cx**2&gt;1
    &#34;&#34;&#34;     
    r,p = getNegBinPars(EX,cx)
    
    s = f&#39;NEGBIN({EX:.2f},{cx:.2f})&#39; if name is None else name
    
    rv = nbinom(r,p)
    cut = int(rv.isf(eps))
    #print(f&#39;cut at {cut}&#39;)
    x = np.arange(cut)
    pk = rv.pmf(x)
    return DiscreteDistribution(x, pk/pk.sum(), name=s)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.POIS"><code class="name flex">
<span>def <span class="ident">POIS</span></span>(<span>y, eps=1e-08, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a Poisson distribution with mean y.</p>
<p>The Poisson distribution is a discrete distribution and has a single parameter
reflecting the mean of the random variable. Since the DiscreteDistribution needs to
have a finite range, the distribution is truncated at the right side if the probabilities
are less than <code>eps</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean of the Poisson distribution.</dd>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code>, optional <code>(default 1e-8)</code></dt>
<dd>Threshold value where to truncate the right part of the CDF.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'POIS(y)')</code></dt>
<dd>Name of the distribution for string representation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Returns a Poisson distribution with parameter y.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the mean value is negative.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def POIS(y, eps=1e-8, name=None):
    r&#34;&#34;&#34;Returns a Poisson distribution with mean y.
    
    The Poisson distribution is a discrete distribution and has a single parameter 
    reflecting the mean of the random variable. Since the DiscreteDistribution needs to 
    have a finite range, the distribution is truncated at the right side if the probabilities
    are less than `eps`.
    
    Parameters
    ----------
    y : float
        Mean of the Poisson distribution.
    eps : float, optional (default 1e-8)
        Threshold value where to truncate the right part of the CDF.
    name : string, optional (default &#39;POIS(y)&#39;)
        Name of the distribution for string representation.

    Returns
    -------
    DiscreteDistribution
        Returns a Poisson distribution with parameter y.
        
    Raises
    -------
    ValueError
        If the mean value is negative.
    &#34;&#34;&#34;   
    if y&lt;0:
        raise ValueError(f&#39;POIS: mean value {y:.2f} out of range&#39;)
    
    s = f&#39;POIS({y:.2f})&#39; if name is None else name
    
    rv = poisson(y)
    cut = int(rv.isf(eps))
    #print(f&#39;cut at {cut}&#39;)
    x = np.arange(cut)
    pk = rv.pmf(x)
    return DiscreteDistribution(x, pk/pk.sum(), name=s)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.conv"><code class="name flex">
<span>def <span class="ident">conv</span></span>(<span>A, B, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sum of the random variables A+B using convolution operator.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="discreteTimeAnalysis.DiscreteDistribution.conv" href="#discreteTimeAnalysis.DiscreteDistribution.conv">DiscreteDistribution.conv()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conv(A,B,name=None):
    r&#34;&#34;&#34;Returns the sum of the random variables A+B using convolution operator.
    
    See also
    ----------
    `DiscreteDistribution.conv`
    &#34;&#34;&#34;        
    return A.conv(B, name=name)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.getNegBinPars"><code class="name flex">
<span>def <span class="ident">getNegBinPars</span></span>(<span>mu, cx)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the two parameters of a negative binomial distribution for given mean and coefficient of variation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mu</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean value.</dd>
<dt><strong><code>cx</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient of variation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>a,b : float, float</code></dt>
<dd>Parameters of the negative binomial distribution.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the parameter range is violated: mu<em>cx</em>*2&gt;1</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNegBinPars(mu,cx):
    r&#34;&#34;&#34;Returns the two parameters of a negative binomial distribution for given mean and coefficient of variation.

    Parameters
    ----------
    mu : float
        Mean value.
    cx : float
        Coefficient of variation.

    Returns
    -------
    a,b : float, float
        Parameters of the negative binomial distribution.
        
    Raises
    -------
    ValueError
        If the parameter range is violated: mu*cx**2&gt;1
    &#34;&#34;&#34;     
    if mu*cx**2&lt;=1:
        raise ValueError(f&#39;getNegBinPars: parameter range is not possible, mu*cx**2={mu*cx**2:2.f}&lt;=1 &#39;)    
    z = cx**2*mu-1    
    return mu/z, 1- z/(cx**2*mu)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.kingman"><code class="name flex">
<span>def <span class="ident">kingman</span></span>(<span>EA, cA, EB, cB)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Kingman approximation for the mean waiting time of a GI/GI/1 queue.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>EA</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean interarrival time.</dd>
<dt><strong><code>cA</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient of variation of the interarrival time.</dd>
<dt><strong><code>EB</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean service time.</dd>
<dt><strong><code>cB</code></strong> :&ensp;<code>float</code></dt>
<dd>Coefficient of variation of the service time.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Kingman approximation of the mean waiting time.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the system utilization EB/EA&gt;1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kingman(EA, cA, EB, cB):
    r&#34;&#34;&#34;Returns the Kingman approximation for the mean waiting time of a GI/GI/1 queue.

    Parameters
    ----------
    EA : float
        Mean interarrival time.
    cA : float
        Coefficient of variation of the interarrival time.
    EB : float
        Mean service time.
    cB : float
        Coefficient of variation of the service time.

    Returns
    -------
    float
        Kingman approximation of the mean waiting time.
        
    Raises
    -------
    ValueError
        If the system utilization EB/EA&gt;1.
    &#34;&#34;&#34;     
    rho = EB/EA
    raise ValueError(f&#39;Kingman: System utilization is rho={rho:.2f}&gt;1&#39;)
    return rho/(1-rho)*EB*(cA**2+cB**2)/2</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.lindley_equation"><code class="name flex">
<span>def <span class="ident">lindley_equation</span></span>(<span>W0, C, epsProb=1e-16)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the Lindley equation.</p>
<p>Solves the discrete-time Lindley equation which is used for the analysis of the waiting time
in a GI/GI/1 system. </p>
<p><span><span class="MathJax_Preview">
w(k)
=
\pi_0 \Big(w(k) * c(k)\Big)
</span><script type="math/tex; mode=display">
w(k)
=
\pi_0 \Big(w(k) * c(k)\Big)
</script></span></p>
<p>The solution is derived by iteration for a given starting distribution <code>W0</code> until the difference <span><span class="MathJax_Preview">W_{n+1}-W_{n} </span><script type="math/tex">W_{n+1}-W_{n} </script></span> between
subsequent distributions is below the treshold <code><a title="discreteTimeAnalysis.comparisonEQ_eps" href="#discreteTimeAnalysis.comparisonEQ_eps">comparisonEQ_eps</a></code>.</p>
<p><span><span class="MathJax_Preview">
W_{n+1} = \max(0, W_n+B-A) \\
w_{n+1} (k)
=
\pi_0
(w_n(k) * c_n(k))
</span><script type="math/tex; mode=display">
W_{n+1} = \max(0, W_n+B-A) \\
w_{n+1} (k)
=
\pi_0
(w_n(k) * c_n(k))
</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>W0</code></strong> :&ensp;<code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>The initial system distribution.</dd>
<dt><strong><code>C</code></strong> :&ensp;<code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>The characteristic function of the system.</dd>
<dt><strong><code>eps</code></strong> :&ensp;<code>float (default 1e-16)</code></dt>
<dd>Threshold which leading or trailing probabilities are to be removed. See <code><a title="discreteTimeAnalysis.DiscreteDistribution.trimPMF" href="#discreteTimeAnalysis.DiscreteDistribution.trimPMF">DiscreteDistribution.trimPMF()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Steady-state distribution of the stationary discrete-time Lindley equation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lindley_equation(W0, C, epsProb=1e-16):
    r&#34;&#34;&#34;Implements the Lindley equation.

    Solves the discrete-time Lindley equation which is used for the analysis of the waiting time
    in a GI/GI/1 system. 
    
    $$
    w(k)  =   \pi_0 \Big(w(k) * c(k)\Big) 
    $$
    
    The solution is derived by iteration for a given starting distribution `W0` until the difference \(W_{n+1}-W_{n} \) between
    subsequent distributions is below the treshold `discreteTimeAnalysis.comparisonEQ_eps`.
    
    $$ 
    W_{n+1} = \max(0, W_n+B-A) \\
    w_{n+1} (k)  =  \pi_0  (w_n(k) * c_n(k)) 
    $$

    Parameters
    ----------
    W0 : DiscreteDistribution
        The initial system distribution.
    C : DiscreteDistribution
        The characteristic function of the system.
    eps : float (default 1e-16)
        Threshold which leading or trailing probabilities are to be removed. See `DiscreteDistribution.trimPMF`.  

    Returns
    -------
    DiscreteDistribution
        Steady-state distribution of the stationary discrete-time Lindley equation.
    &#34;&#34;&#34;         
    Wn = W0
    Wn1 = DiscreteDistribution([-1], [1])
    i = 0
    
    while Wn1 != Wn:
        Wn1 = pi0(Wn+C)
        
        Wn = Wn1
        Wn.name = None
        Wn.trimPMF(eps=epsProb)
        i += 1
    return Wn, i</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.max"><code class="name flex">
<span>def <span class="ident">max</span></span>(<span>A, m, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the pi-operator applied to the distribution A.</p>
<p>The pi-operator means the maximum of this random variable and the value m.
The following two expressions are identical: <code><a title="discreteTimeAnalysis.max" href="#discreteTimeAnalysis.max">max()</a>(A,0)</code> and <code><a title="discreteTimeAnalysis.pi_op" href="#discreteTimeAnalysis.pi_op">pi_op()</a>(A,m)</code>.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="discreteTimeAnalysis.DiscreteDistribution.pi_op" href="#discreteTimeAnalysis.DiscreteDistribution.pi_op">DiscreteDistribution.pi_op()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max(A, m, name=None):    
    r&#34;&#34;&#34;Returns the pi-operator applied to the distribution A.
    
    The pi-operator means the maximum of this random variable and the value m. 
    The following two expressions are identical: `max(A,0)` and `pi_op(A,m)`.
    
    See also
    ----------
    `DiscreteDistribution.pi_op`
    &#34;&#34;&#34; 
    return A.pi_op(m, name)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.pi0"><code class="name flex">
<span>def <span class="ident">pi0</span></span>(<span>A, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the pi0-operator applied to A.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="discreteTimeAnalysis.DiscreteDistribution.pi0" href="#discreteTimeAnalysis.DiscreteDistribution.pi0">DiscreteDistribution.pi0()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pi0(A, name=None):
    r&#34;&#34;&#34;Returns the pi0-operator applied to A.
    
    See also
    ----------
    `DiscreteDistribution.pi0`
    &#34;&#34;&#34; 
    return A.pi0(name=name)    </code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.pi_op"><code class="name flex">
<span>def <span class="ident">pi_op</span></span>(<span>A, m=0, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the pi-operator applied to A.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="discreteTimeAnalysis.DiscreteDistribution.pi_op" href="#discreteTimeAnalysis.DiscreteDistribution.pi_op">DiscreteDistribution.pi_op()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pi_op(A, m=0, name=None):    
    r&#34;&#34;&#34;Returns the pi-operator applied to A.
    
    See also
    ----------
    `DiscreteDistribution.pi_op`
    &#34;&#34;&#34; 
    return A.pi_op(m, name)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.plotCDF"><code class="name flex">
<span>def <span class="ident">plotCDF</span></span>(<span>A, addZero=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the CDF of the distribution <code>A</code>. </p>
<h2 id="see-also">See Also</h2>
<p><code><a title="discreteTimeAnalysis.DiscreteDistribution.plotCDF" href="#discreteTimeAnalysis.DiscreteDistribution.plotCDF">DiscreteDistribution.plotCDF()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotCDF(A, addZero=True, **kwargs):
    r&#34;&#34;&#34;Plots the CDF of the distribution `A`. 
    
    See also
    ----------
    `DiscreteDistribution.plotCDF`
    &#34;&#34;&#34;      
    A.plotCDF(addZero, **kwargs)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.plotPMF"><code class="name flex">
<span>def <span class="ident">plotPMF</span></span>(<span>A, addZero=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the PMF of the distribution <code>A</code>. </p>
<h2 id="see-also">See Also</h2>
<p><code><a title="discreteTimeAnalysis.DiscreteDistribution.plotPMF" href="#discreteTimeAnalysis.DiscreteDistribution.plotPMF">DiscreteDistribution.plotPMF()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotPMF(A, addZero=True, **kwargs):
    r&#34;&#34;&#34;Plots the PMF of the distribution `A`. 
    
    See also
    ----------
    `DiscreteDistribution.plotPMF`
    &#34;&#34;&#34;      
    A.plotPMF(addZero, **kwargs)    </code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="discreteTimeAnalysis.DiscreteDistribution"><code class="flex name class">
<span>class <span class="ident">DiscreteDistribution</span></span>
<span>(</span><span>xk, pk, name='discrete distr.')</span>
</code></dt>
<dd>
<div class="desc"><p>The class implements finite discrete distributions representing discrete random variables.</p>
<p>A discrete distribution reflects a random variable <span><span class="MathJax_Preview"> X </span><script type="math/tex"> X </script></span> and is defined
by its probability mass function (PMF). The random variable can take discrete values
which are defined by the numpy array <code>xk</code> (sample space). The probability that the random variable
takes a certain value is <span><span class="MathJax_Preview"> P(X=k)=p_k </span><script type="math/tex"> P(X=k)=p_k </script></span>. The probabilities are stored in the
numpy array <code>pk</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>xk</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>Values of the distribution (sample space).</dd>
<dt><strong><code>pk</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>Probabilities corresponding to the sample space.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>Arbitrary name of that distribution.</dd>
</dl>
<p>A discrete distribution is initialized with value range <code>xk</code>and probabilities <code>pk</code>.</p>
<p>For the initialization of a discrete random variable, the sample space <code>xk</code> and the corresponding
probabilities <code>pk</code> are required. Both parameters are then stored as class attributes in form
of numpy array (one-dimensional). In addition, an arbitrary <code>name</code> can be passed to the
distribution which is used when printing an instance of the class, see e.g.
<code><a title="discreteTimeAnalysis.DiscreteDistribution.describe" href="#discreteTimeAnalysis.DiscreteDistribution.describe">DiscreteDistribution.describe()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xk</code></strong> :&ensp;<code>numpy array</code> or <code>list</code></dt>
<dd>Values of the distribution.</dd>
<dt><strong><code>pk</code></strong> :&ensp;<code>numpy array</code> or <code>list</code></dt>
<dd>Probabilities corresponding to the values: <span><span class="MathJax_Preview"> P(X=xk)=pk </span><script type="math/tex"> P(X=xk)=pk </script></span>.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'discrete distr.')</code></dt>
<dd>Name of the distribution for string representation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DiscreteDistribution:
    r&#34;&#34;&#34;The class implements finite discrete distributions representing discrete random variables.

    A discrete distribution reflects a random variable \( X \) and is defined 
    by its probability mass function (PMF). The random variable can take discrete values
    which are defined by the numpy array `xk` (sample space). The probability that the random variable
    takes a certain value is \( P(X=k)=p_k \). The probabilities are stored in the
    numpy array `pk`.
    

    Attributes
    ----------
    xk : numpy array
        Values of the distribution (sample space).
    pk : numpy array
        Probabilities corresponding to the sample space.
    name : string
        Arbitrary name of that distribution. 

    &#34;&#34;&#34;    
    
    def __init__(self, xk, pk, name=&#39;discrete distr.&#39;):         
        r&#34;&#34;&#34;A discrete distribution is initialized with value range `xk`and probabilities `pk`.
        
        For the initialization of a discrete random variable, the sample space `xk` and the corresponding
        probabilities `pk` are required. Both parameters are then stored as class attributes in form
        of numpy array (one-dimensional). In addition, an arbitrary `name` can be passed to the
        distribution which is used when printing an instance of the class, see e.g. 
        `DiscreteDistribution.describe`.

        Parameters
        ----------
        xk : numpy array or list
            Values of the distribution.
        pk : numpy array or list
            Probabilities corresponding to the values: \( P(X=xk)=pk \).
        name : string, optional (default &#39;discrete distr.&#39;)
            Name of the distribution for string representation.

        &#34;&#34;&#34;        
        assert len(xk)==len(pk) # same length        
        
        self.xmin = np.min(xk)
        self.xmax = np.max(xk)
        
        # adjust to vector xk without gaps
        self.xk = np.arange(self.xmin, self.xmax+1, dtype=&#39;int&#39;)
        self.pk = np.zeros( len(self.xk) )
        self.pk[xk-self.xmin] = pk
        self.name = name
        
    def mean(self):
        r&#34;&#34;&#34;Returns the mean value of the distribution \( E[X] \).
    
    
        Returns
        -------
        float
            Mean value.
            
        &#34;&#34;&#34;        
        return np.sum(self.xk*self.pk)
    
    def var(self):
        r&#34;&#34;&#34;Returns the variance of the distribution \( VAR[X] \).
    
    
        Returns
        -------
        float
            Variance of the distribution.
            
        &#34;&#34;&#34;                
        return np.sum(self.xk**2*self.pk)-self.mean()**2
    
    def std(self):
        r&#34;&#34;&#34;Returns the standard deviation of the distribution \( {STD}[X]=\sqrt{VAR[X]} \).
    
    
        Returns
        -------
        float
            Standard deviation of the distribution.
            
        &#34;&#34;&#34;                
        return math.sqrt(self.var())
    
    def cx(self):
        r&#34;&#34;&#34;Returns the coefficient of the variation of the distribution \( c_X = STD[X]/E[X] \).
    
    
        Returns
        -------
        float
            Coefficient of variation of the distribution.
            
        &#34;&#34;&#34;               
        return self.std()/self.mean()
    
    def mode(self):
        r&#34;&#34;&#34;Returns the mode of the distribution.
    
    
        Returns
        -------
        float
            Mode of the distribution.
            
        &#34;&#34;&#34;                
        return self.xk[np.argmax(self.pk)]
    
    def quantile(self, q=0.95):
        r&#34;&#34;&#34;Returns the q-quantile of the distribution.
    
        Parameters
        ----------
        q : float, optional (default 0.95)
            The parameter indicates that the q-quantile is derived. The default value is `q=0.95`
            for the 95%-quantile. It must be ensured that \( 0&lt; q &lt; 1\).
    
        Returns
        -------
        float
            q-Quantile (default 95%) of the distribution.
            
        &#34;&#34;&#34;                
        return self.xk[np.argmax(self.pk.cumsum()&gt;q)]
    
    def describe(self):
        r&#34;&#34;&#34;Prints basic characteristics of the distribution.        
        
        This method prints basic characteristics of the distribution.
        
        Example
        -------
        &gt;&gt;&gt; A.describe()
            interarrival_time: EX=5.5000, cX=0.5222, mode=1 
                        
        &#34;&#34;&#34;               
        print(f&#39;{self.name}: EX={self.mean():.4f}, cX={self.cx():.4f}, mode={self.mode()} &#39;)

    def checkDistribution(self):
        r&#34;&#34;&#34;Returns if the distribution is valid.         
    
        Returns
        -------
        bool
            Return true if the distribution is valid. 
            Returns false if e.g. the values of `xk` are not increasing or the sum of probabilities `pk` is less than 1.
            
        &#34;&#34;&#34;                
        increasing = np.all(np.diff(self.xk) &gt; 0) # xk: strictly monotonic increasing
        sumOne = abs(np.sum(self.pk)-1)&lt;1e-8 # xk: error
        return increasing and sumOne
            
    def conv(self, other,name=None):
        r&#34;&#34;&#34;Returns the sum of this distributions and another distribution.
        
        Returns the sum of this distribution and the other distribution. Note that \( A+B=B+A \).
        The operator `+` is overloaded for that class, such that `A+B` is an abbreviation for `A.conv(B)`.
        
        
        Parameters
        ----------
        other : DiscreteDistribution
            The other distribution of the sum.
        name : string, optional (default &#39;self.name+other.name&#39;)
            Name of the distribution for string representation.
            
        Example
        -------
        &gt;&gt;&gt; A = DU()
        &gt;&gt;&gt; A.conv(A) # returns A+A
        &gt;&gt;&gt; DiscreteDistribution.conv(A,A) # returns A+A
        &gt;&gt;&gt; A+A # returns A+A
    
        Returns
        -------
        DiscreteDistribution
            Sum of the distributions: `self+other`.
                    
        &#34;&#34;&#34;                
        s = f&#39;{self.name}+{other.name}&#39; if name is None else name     
        pk = np.convolve(self.pk, other.pk)
        xk = np.arange(self.xmin+other.xmin, self.xmax+other.xmax+1)
        return DiscreteDistribution(xk,pk,name=s)    
    
    def convNeg(self, other, name=None):
        r&#34;&#34;&#34;Returns the difference of two distributions.
        
        Returns the difference of this distribution and the other distribution. 
        The operator `-` is overloaded for that class, such that `A-B` is an abbreviation for `A.convNeg(B)`.
        
        
        Parameters
        ----------
        B : DiscreteDistribution
            The other distribution to be substracted from this distribution.
        name : string, optional (default &#39;A.name-B.name&#39;)
            Name of the distribution for string representation.
            
        Example
        -------
        &gt;&gt;&gt; A = DU()
        &gt;&gt;&gt; A.convNeg(A) # returns A-A
        &gt;&gt;&gt; DiscreteDistribution.convNeg(A,A) # returns A-A
        &gt;&gt;&gt; A-A # returns A-A
    
        Returns
        -------
        DiscreteDistribution
            Difference of the distributions: `self-other`.
                    
        &#34;&#34;&#34;
        s = f&#39;{self.name}-{other.name}&#39; if name is None else name     
        pk = np.convolve(self.pk, other.pk[::-1])
        xk = np.arange(self.xmin-other.xmax, self.xmax-other.xmin+1)
        return DiscreteDistribution(xk,pk,name=s)
        
    def pi_op(self, m=0, name=None):        
        r&#34;&#34;&#34;Applies the pi-operator (summing up probabilities to m) and returns the resulting distribution.
        
        The pi-operator truncates a distribution at the point \(X=m\) and sums up the probabilities. 
        The probability mass \( P(X\leq m) \) is assigned
        to the point \(X=m\), while all other probabilities are set to zero for \(X&lt;m\). The default operation is 
        to delete all negative values and assigning the probability mass of negative values to \(X=0\). 
        Hence, the default value is \(m=0\) and in this case \(P(X&#39;=0 ) = \sum_{i=-\infty}^0 P(X=i)\), while the probabilites for all negative values 
        are set to zero \(P(X&#39;= i ) = 0, \forall i&lt;0\) for the resulting distribution \(X&#39;\). The rest of the distribution \(i&gt;0 \) is not changed.
                                              
        In general: \(P(X&#39;=0 ) = \sum_{i=-\infty}^m P(X=i)\). Hence, for a distribution \(x(k)=P(X=k) \), 
        the pi-operator works as follows:

        $$
        \pi_m \Big(x(k)\Big)  =  \begin{cases}
                0 &amp; k &lt; m \\
                \sum\limits_{i = - \infty}^m
                   x(i) &amp; k= m \\
                x(k) &amp; k &gt; m \\
        \end{cases} 
        $$                              
        
        Parameters
        ----------
        m : integer
            The truncation point at which probabilities are summed up.
        name : string, optional (default &#39;pi_m(self.name)&#39;)
            Name of the distribution for string representation.
            
        Returns
        -------
        DiscreteDistribution
            Truncated distribution.
                    
        &#34;&#34;&#34;
        s = f&#39;pi_{m}({self.name})&#39; if name is None else name     
        if m &lt;= self.xmin:
            self.name = s
            return self
        elif m &gt;= self.xmax:
            return  DiscreteDistribution([m],[1],name=s)
        else:
            #s = f&#39;pi_{m}({A.name})&#39; if name is None else name        
            k = np.searchsorted(self.xk,m)
            xk = np.arange(m, self.xmax+1)
            pk = np.zeros(len(xk))
            pk[0] = np.sum(self.pk[0:k+1])
            pk[1:] = self.pk[k+1:]
            return DiscreteDistribution(xk,pk,name=s)
            
    def pi0(self, name=None):
        r&#34;&#34;&#34;Applies the pi-operator (truncation of negative values, summing up probabilities ) and returns the resulting distribution.
        
        The pi0-operator truncates the distribution at 0 and sums up the probabilities.  The probability mass of negative values is assigned to 0. 
        For the resulting distribution \(X&#39;\), it is \(P(X&#39;=0 ) = \sum_{i=-\infty}^0 P(X=i)\), while the probabilites for all negative values 
        are set to zero \(P(X&#39;= i ) = 0, \forall i&lt;0\). The rest of the distribution \(i&gt;0 \) is not changed.
                            
        $$
        \pi_0 \Big(x(k)\Big)  =  \begin{cases}
                0 &amp; k &lt; 0 \\
                \sum\limits_{i = - \infty}^0
                   x(i) &amp; k= 0 \\
                x(k) &amp; k &gt; 0 \\
        \end{cases} 
        $$
                                              
        Parameters
        ----------
        name : string, optional (default &#39;pi0(self.name)&#39;)
            Name of the distribution for string representation.
            
        Returns
        -------
        DiscreteDistribution
            Truncated distribution.

        See also
        -------
        Generalized truncation `DiscreteDistribution.pi_op`
        &#34;&#34;&#34;

        s = f&#39;pi0({self.name})&#39; if name is None else name
        return self.pi_op(m=0, name=s)
    
    def _trim(self, m, normalize=True):
        r&#34;&#34;&#34;Truncates the distribution from left and right side. 
        
        The operation uses the minimum and maximum of the values m and truncates the distribution to 
        this range. It changes the value range `xk` and the corresponding probabilities `pk`.

        Parameters
        ----------
        m : numpy array of boolean values
            The first and the last True value in the array are used to truncate the distribution.
        normalize : bool
            If True, the distribution is renormalized. If False, the distribution is truncated.
            
        Returns
        -------
        None
        &#34;&#34;&#34;                      
        kmin = m.argmax()
        kmax = m.size - m[::-1].argmax()-1
        
        #A.xmin = np.min(xk)
        #A.xmax = np.max(xk)        
        
        self.xk = self.xk[kmin:kmax+1]
        self.pk = self.pk[kmin:kmax+1]
        
        self.xmin = self.xk[0]
        self.xmax = self.xk[-1]
        
        if normalize:
            self.pk /= self.pk.sum()
        return
    
    def trim(self, normalize=True):
        r&#34;&#34;&#34;Remove trailing and leading diminishing probabilities. 
        
        The trim-operation changes the value range `xk` and the corresponding probabilities `pk` by removing
        any leading and any trailing diminishing probabilities. This distribution object is therefore changed.
        
        Parameters
        ----------        
        normalize : bool
            If True, the distribution is renormalized. If False, the distribution is truncated.

        Returns
        -------
        None
        &#34;&#34;&#34;                
        m = self.pk!=0        
        self._trim(m, normalize)
        return 
    
    def trimPMF(self, eps=1e-8, normalize=True):
        r&#34;&#34;&#34;Remove trailing and leading diminishing probabilities below a certain threshold. 
        
        The trimPMF-operation changes the value range `xk` and the corresponding probabilities `pk` by removing
        any leading and any trailing diminishing probabilities which are less than `eps`. 
        This distribution object is therefore changed.

        Parameters
        ----------
        eps : float
            Threshold which leading or trailing probabilities are to be removed.
        normalize : bool
            If True, the distribution is renormalized. If False, the distribution is truncated.
            
        Returns
        -------
        None        

        &#34;&#34;&#34;                
        m = self.pk&gt;eps #!=0        
        self._trim(m, normalize)
        return
    
    def trimCDF(self, eps=1e-8, normalize=True):
        r&#34;&#34;&#34;Remove trailing and leading diminishing cumulative probabilities below a certain threshold. 
        
        The trimCDF-operation changes the value range `xk` and the corresponding probabilities `pk` 
        by removing any leading and any trailing diminishing cumulative probabilities which are less than `eps`. 
        This distribution object is therefore changed.

        Parameters
        ----------
        eps : float
            Threshold which leading or trailing cumulative probabilities are to be removed.
        normalize : bool
            If True, the distribution is renormalized. If False, the distribution is truncated.
            
        Returns
        -------
        None        
        &#34;&#34;&#34;                
        m = self.pk.cumsum()&gt;eps #!=0        
        self._trim(m, normalize)
        return    
    
    
    # this is an unnormalized distribution: 
    # conditional distribution if normalized
    # sigmaLT = sigma^m: takes the lower part ( k &lt; m ) of a distribution
    def sigmaTakeLT(self, m=0, name=None, normalized=True):        
        r&#34;&#34;&#34;Applies the sigma-operator and returns the result.
        
        The sigma-operator returns the lower or the upper part of the distribution. 
        `sigmaTakeLT` implements the \(\sigma^m\)-operator which sweeps away the upper part \(k\geq m\) 
        and takes the lower part \(k &lt; m \). The distribution is therefore truncated. 
        The results of these operations are unnormalized distributions where the sum of the probabilities
        is less than one:
        $$\sigma^m[x(k)] = 
                \begin{cases}
                x(k) &amp; k&lt;m \\
                0 &amp; k \geq m 
        \end{cases}
        $$

        The parameter `normalized` (default True) indicates that a normalized distribution
        (conditional random variable) is returned, such that the sum of probabilities is one.
        The parameter `m` indicates at which point the distribution is truncated.
        
        Parameters
        ----------
        m : integer
            Truncation point. The lower part \(k &lt; m \) of the distribution is taken.        
        name : string, optional (default &#39;sigma^{m}({self.name})&#39;)
            Name of the distribution for string representation.
        normalized : bool
            If true returns a normalized distribution. If false the original probabilities for the 
            truncated range are returned. 
            
        Returns
        -------
        DiscreteDistribution
            Returns normalized or unnormalized truncated distribution taking probabilities for \(k &lt; m \).            

        Raises
        ------
        ValueError
            If m is less than the smallest value xmin of this distribution. 
            
        &#34;&#34;&#34;                
        #assert m&lt;xk[-1]
        s = f&#39;sigma^{m}({self.name})&#39; if name is None else name     
                
        if m&lt;=self.xk[0]:
            if normalized: 
                raise ValueError(&#39;sigmaLT: m &lt; min(xk)&#39;)
            else:
                return DiscreteDistribution([m], [0], name=s)
        if m&gt;self.xk[-1]:
            return DiscreteDistribution(self.xk, self.pk, name=s)
            
        last = np.searchsorted(self.xk, m, side=&#39;right&#39;)-1        
        
        xk=self.xk[:last]
        if normalized:
            prob_Dist_U_lt_m = self.pk[:last].sum() 
            pk=self.pk[:last] / prob_Dist_U_lt_m
        else:
            pk=self.pk[:last]                
        return DiscreteDistribution(xk, pk, name=s)
    
    # this is an unnormalized distribution: 
    # conditional distribution if normalized
    def sigmaTakeGEQ(self, m=0, name=None, normalized=True):
        r&#34;&#34;&#34;Applies the sigma-operator and returns the result.
        
        The sigma-operator returns the lower or the upper part of the distribution. 
        `sigmaTakeGEQ` implements the \(\sigma_m\)-operator which sweeps away the lower part \(k &lt; m \) 
        and takes the upper part \( k \geq m \). The distribution is therefore truncated. 
        The results of these operations are unnormalized distributions where the sum of the probabilities
        is less than one:
        $$    
        \sigma_m[x(k)] = 
                \begin{cases}
                0 &amp; k&lt;m \\
                x(k) &amp; k \geq m
                \end{cases} 
        $$

        The parameter `normalized` (default True) indicates that a normalized distribution
        (conditional random variable) is returned, such that the sum of probabilities is one.
        The parameter `m` indicates at which point the distribution is truncated.
        
        Parameters
        ----------
        m : integer
            Truncation point. The upper part \(k\geq m\) of the distribution is taken.        
        name : string, optional (default &#39;sigma_{m}({self.name})&#39;)
            Name of the distribution for string representation.
        normalized : bool
            If true returns a normalized distribution. If false the original probabilities for the 
            truncated range are returned. 
            
        Returns
        -------
        DiscreteDistribution
            Returns normalized or unnormalized truncated distribution taking probabilities for \(k \geq m \).

        &#34;&#34;&#34;
        s = f&#39;sigma_{m}({self.name})&#39; if name is None else name     
        #assert m&gt;=self.xk[0]
        if m&gt;self.xk[-1]:
            if normalized: 
                raise ValueError(&#39;sigmaGEQ: m &gt; max(xk)&#39;)
            else:
                return DiscreteDistribution([m], [0], name=s)                    
        
        first = np.searchsorted(self.xk, m, side=&#39;left&#39;)
        
        xk=self.xk[first:]
        if normalized:
            prob_Dist_U_geq_m = self.pk[first:].sum() 
            pk=self.pk[first:] / prob_Dist_U_geq_m
        else:
            pk=self.pk[first:]                
        return DiscreteDistribution(xk, pk, name=s)
    
    def pmf(self, xi):
        r&#34;&#34;&#34;Probability mass function at xi of the given distribution.

        Parameters
        ----------
        xi : numpy array or integer
            Quantiles.
            
        Returns
        -------
        numpy array of float
            Probability mass function evaluated at xi.
        &#34;&#34;&#34;                
        #myxk = np.arange(self.xmin-1, self.xmax+2)
        #mypk = np.hstack((0, self.pk, 0))
        if type(xi) is not np.ndarray:
            if type(xi) is list:
                xi = np.array(xi)
            else:
                xi = np.array([xi])
        
        i = np.where( (xi&gt;=self.xmin) &amp; (xi&lt;=self.xmax) )[0]
        mypk = np.zeros(len(xi))
        
        if len(i)&gt;0:            
            mypk[i] = self.pk[np.searchsorted(self.xk, xi[i], side=&#39;left&#39;)]
        return mypk
    
    def cdf(self, xi):
        r&#34;&#34;&#34;Cumulative distribution function at xi of the given distribution.

        Parameters
        ----------
        xi : numpy array or integer
            Quantiles.
            
        Returns
        -------
        numpy array of float
            Cumulative distribution function evaluated at xi.
        &#34;&#34;&#34;                
        #myxk = np.arange(self.xmin-1, self.xmax+2)
        #mypk = np.hstack((0, self.pk, 0))
        PK = self.pk.cumsum()
        if type(xi) is not np.ndarray:
            if type(xi) is list:
                xi = np.array(xi)
            else:
                xi = np.array([xi])
        
        i = np.where( (xi&gt;=self.xmin) &amp; (xi&lt;=self.xmax) )[0]
        mypk = np.zeros(len(xi))
        
        if len(i)&gt;0:            
            mypk[i] = PK[np.searchsorted(self.xk, xi[i], side=&#39;left&#39;)]
        return mypk
    
    def plotCDF(self,  addZero=True, **kwargs):
        r&#34;&#34;&#34;Plots the cumulative distribution function of this distrribution.

        Parameters
        ----------
        addZero : bool (default True)
            If true the zero point will be explicitly plotted, otherwise not.
        **kwargs: 
            Arbitrary keyword arguments are passed to `Matplotlib.pyplot.step`.
            
        Returns
        -------
        None
        &#34;&#34;&#34;                
        if addZero and self.xk[0]&gt;=0:
            x = np.insert(self.xk,0,0)
            y = np.insert(self.pk,0,0)
        else:
            x, y = self.xk, self.pk
        
        x = np.append(x, x[-1]+1)
        Y = np.append(y.cumsum(), 1)
        
        plt.step(x, Y, &#39;.-&#39;, where=&#39;post&#39;, **kwargs)
        
    def plotPMF(self,  **kwargs):
        r&#34;&#34;&#34;Plots the probability mass function of this distrribution.

        Parameters
        ----------        
        **kwargs: 
            Arbitrary keyword arguments are passed to `Matplotlib.pyplot.plot`.
            
        Returns
        -------
        None
        &#34;&#34;&#34;                
        plt.plot(self.xk, self.pk, &#39;.-&#39;, **kwargs)        
        
    def conditionalRV(self, condition, name=None, normalized=True):
        r&#34;&#34;&#34;Returns the normalized or unnormalized conditional random variable.

        Parameters
        ----------
        condition : function
            Applies the function `condition` to match the corresponding values of the distribution.        
        name : string, optional (default &#39;{self.name}&#39;)
            Name of the distribution for string representation.
        normalized : bool (default True)
            If true returns a normalized distribution. If false returns the original probabilities for the 
            range where the condition is true. 
            
        Returns
        -------
        DiscreteDistribution
            Returns the conditional distribution for which the condition (applied to `xk`) is true. 
            The resulting distribution is normalized if the paraemter `normalized` is true.
            
            
        Raises
        ------
        ValueError
            If the condition is not fulfilled for any value `xk`
            
        &#34;&#34;&#34;     
        s = f&#39;{self.name}|condition&#39; if name is None else name     
        which = condition(self.xk)
        
        Apk = self.pk[which] 
        Axk = self.xk[which] 
        if normalized:            
            if Apk.sum()==0:
                raise ValueError(&#39;conditionalRV: condition is not possible!&#39;)
            return DiscreteDistribution(Axk, Apk/Apk.sum(), name=s)   
        else:
            return DiscreteDistribution(Axk, Apk, name=s)   
        
    
    # A+B
    def __add__(self, other):                
        return DiscreteDistribution.conv(self,other,name=f&#39;{self.name}+{other.name}&#39;)
    
    # A-C
    def __sub__(self, other):                 
        return DiscreteDistribution.convNeg(self,other,name=f&#39;{self.name}-{other.name}&#39;)
    
    # A-C
    def __mul__(A, B):                 
        if isinstance(A,DiscreteDistribution):
            return DiscreteDistribution(A.xk*B,A.pk,name=f&#39;{B}*{A.name}&#39;)
        elif isinstance(B,DiscreteDistribution):
            return DiscreteDistribution(B.xk*A,B.pk,name=f&#39;{A}*{B.name}&#39;)
            
    # A&lt;B: based on means
    def __lt__(self, other):                        
        return self.mean() &lt; other.mean()
    
    # A&lt;=B: based on means
    def __le__(self, other):                        
        return self.mean() &lt;= other.mean()
    
    # A&gt;B: based on means
    def __gt__(self, other):                        
        return self.mean() &gt; other.mean()
    
    # A&gt;=B: based on means
    def __ge__(self, other):                        
        return self.mean() &gt;= other.mean()
    
    # A==B: based on means and threshold comparisonEQ_eps
    def __eq__(self, other):                        
        #if len(self.xk) != len(other.xk): return False
        #return np.all(self.xk==other.xk) and np.all(self.pk==other.pk)
        return abs(self.mean()-other.mean())&lt;=comparisonEQ_eps
    
    # A!=B: based on means and threshold comparisonEQ_eps
    def __ne__(self, other):                        
        return abs(self.mean()-other.mean())&gt;comparisonEQ_eps
    
    def __getExtendedRangeDist(self, xmin, xmax):
        end = np.zeros(xmax-self.xmax) if self.xmax &lt; xmax else []
        start = np.zeros(self.xmin-xmin) if self.xmin &gt; xmin else []    
        return np.concatenate((start, self.pk, end))
        
        
    # A|condition
    def __or__(self, other):
        if callable(other):  # A|condition
            return self.conditionalRV(other)
    
    def __repr__(self):                
        return self.__str__()

    def __str__(self):
        if len(self.xk)&lt;10:
            return f&#39;{self.name}: xk={np.array2string(self.xk,separator=&#34;,&#34;)}, pk={np.array2string(self.pk,precision=3, separator=&#34;,&#34;)}&#39;
        else:
            return f&#39;{self.name}: xk={self.xmin},...,{self.xmax}, pk={self.pk[0]:g},...,{self.pk[-1]:g}&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="discreteTimeAnalysis.DiscreteDistribution.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>self, xi)</span>
</code></dt>
<dd>
<div class="desc"><p>Cumulative distribution function at xi of the given distribution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>numpy array</code> or <code>integer</code></dt>
<dd>Quantiles.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy array</code> of <code>float</code></dt>
<dd>Cumulative distribution function evaluated at xi.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdf(self, xi):
    r&#34;&#34;&#34;Cumulative distribution function at xi of the given distribution.

    Parameters
    ----------
    xi : numpy array or integer
        Quantiles.
        
    Returns
    -------
    numpy array of float
        Cumulative distribution function evaluated at xi.
    &#34;&#34;&#34;                
    #myxk = np.arange(self.xmin-1, self.xmax+2)
    #mypk = np.hstack((0, self.pk, 0))
    PK = self.pk.cumsum()
    if type(xi) is not np.ndarray:
        if type(xi) is list:
            xi = np.array(xi)
        else:
            xi = np.array([xi])
    
    i = np.where( (xi&gt;=self.xmin) &amp; (xi&lt;=self.xmax) )[0]
    mypk = np.zeros(len(xi))
    
    if len(i)&gt;0:            
        mypk[i] = PK[np.searchsorted(self.xk, xi[i], side=&#39;left&#39;)]
    return mypk</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.checkDistribution"><code class="name flex">
<span>def <span class="ident">checkDistribution</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns if the distribution is valid.
</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Return true if the distribution is valid.
Returns false if e.g. the values of <code>xk</code> are not increasing or the sum of probabilities <code>pk</code> is less than 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkDistribution(self):
    r&#34;&#34;&#34;Returns if the distribution is valid.         

    Returns
    -------
    bool
        Return true if the distribution is valid. 
        Returns false if e.g. the values of `xk` are not increasing or the sum of probabilities `pk` is less than 1.
        
    &#34;&#34;&#34;                
    increasing = np.all(np.diff(self.xk) &gt; 0) # xk: strictly monotonic increasing
    sumOne = abs(np.sum(self.pk)-1)&lt;1e-8 # xk: error
    return increasing and sumOne</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.conditionalRV"><code class="name flex">
<span>def <span class="ident">conditionalRV</span></span>(<span>self, condition, name=None, normalized=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the normalized or unnormalized conditional random variable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>condition</code></strong> :&ensp;<code>function</code></dt>
<dd>Applies the function <code>condition</code> to match the corresponding values of the distribution.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default '{self.name}')</code></dt>
<dd>Name of the distribution for string representation.</dd>
<dt><strong><code>normalized</code></strong> :&ensp;<code>bool (default True)</code></dt>
<dd>If true returns a normalized distribution. If false returns the original probabilities for the
range where the condition is true.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Returns the conditional distribution for which the condition (applied to <code>xk</code>) is true.
The resulting distribution is normalized if the paraemter <code>normalized</code> is true.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the condition is not fulfilled for any value <code>xk</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conditionalRV(self, condition, name=None, normalized=True):
    r&#34;&#34;&#34;Returns the normalized or unnormalized conditional random variable.

    Parameters
    ----------
    condition : function
        Applies the function `condition` to match the corresponding values of the distribution.        
    name : string, optional (default &#39;{self.name}&#39;)
        Name of the distribution for string representation.
    normalized : bool (default True)
        If true returns a normalized distribution. If false returns the original probabilities for the 
        range where the condition is true. 
        
    Returns
    -------
    DiscreteDistribution
        Returns the conditional distribution for which the condition (applied to `xk`) is true. 
        The resulting distribution is normalized if the paraemter `normalized` is true.
        
        
    Raises
    ------
    ValueError
        If the condition is not fulfilled for any value `xk`
        
    &#34;&#34;&#34;     
    s = f&#39;{self.name}|condition&#39; if name is None else name     
    which = condition(self.xk)
    
    Apk = self.pk[which] 
    Axk = self.xk[which] 
    if normalized:            
        if Apk.sum()==0:
            raise ValueError(&#39;conditionalRV: condition is not possible!&#39;)
        return DiscreteDistribution(Axk, Apk/Apk.sum(), name=s)   
    else:
        return DiscreteDistribution(Axk, Apk, name=s)   </code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.conv"><code class="name flex">
<span>def <span class="ident">conv</span></span>(<span>self, other, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sum of this distributions and another distribution.</p>
<p>Returns the sum of this distribution and the other distribution. Note that <span><span class="MathJax_Preview"> A+B=B+A </span><script type="math/tex"> A+B=B+A </script></span>.
The operator <code>+</code> is overloaded for that class, such that <code>A+B</code> is an abbreviation for <code>A.conv(B)</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>The other distribution of the sum.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'self.name+other.name')</code></dt>
<dd>Name of the distribution for string representation.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; A = DU()
&gt;&gt;&gt; A.conv(A) # returns A+A
&gt;&gt;&gt; DiscreteDistribution.conv(A,A) # returns A+A
&gt;&gt;&gt; A+A # returns A+A
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Sum of the distributions: <code>self+other</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conv(self, other,name=None):
    r&#34;&#34;&#34;Returns the sum of this distributions and another distribution.
    
    Returns the sum of this distribution and the other distribution. Note that \( A+B=B+A \).
    The operator `+` is overloaded for that class, such that `A+B` is an abbreviation for `A.conv(B)`.
    
    
    Parameters
    ----------
    other : DiscreteDistribution
        The other distribution of the sum.
    name : string, optional (default &#39;self.name+other.name&#39;)
        Name of the distribution for string representation.
        
    Example
    -------
    &gt;&gt;&gt; A = DU()
    &gt;&gt;&gt; A.conv(A) # returns A+A
    &gt;&gt;&gt; DiscreteDistribution.conv(A,A) # returns A+A
    &gt;&gt;&gt; A+A # returns A+A

    Returns
    -------
    DiscreteDistribution
        Sum of the distributions: `self+other`.
                
    &#34;&#34;&#34;                
    s = f&#39;{self.name}+{other.name}&#39; if name is None else name     
    pk = np.convolve(self.pk, other.pk)
    xk = np.arange(self.xmin+other.xmin, self.xmax+other.xmax+1)
    return DiscreteDistribution(xk,pk,name=s)    </code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.convNeg"><code class="name flex">
<span>def <span class="ident">convNeg</span></span>(<span>self, other, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the difference of two distributions.</p>
<p>Returns the difference of this distribution and the other distribution.
The operator <code>-</code> is overloaded for that class, such that <code>A-B</code> is an abbreviation for <code>A.convNeg(B)</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>B</code></strong> :&ensp;<code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>The other distribution to be substracted from this distribution.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'A.name-B.name')</code></dt>
<dd>Name of the distribution for string representation.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; A = DU()
&gt;&gt;&gt; A.convNeg(A) # returns A-A
&gt;&gt;&gt; DiscreteDistribution.convNeg(A,A) # returns A-A
&gt;&gt;&gt; A-A # returns A-A
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Difference of the distributions: <code>self-other</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convNeg(self, other, name=None):
    r&#34;&#34;&#34;Returns the difference of two distributions.
    
    Returns the difference of this distribution and the other distribution. 
    The operator `-` is overloaded for that class, such that `A-B` is an abbreviation for `A.convNeg(B)`.
    
    
    Parameters
    ----------
    B : DiscreteDistribution
        The other distribution to be substracted from this distribution.
    name : string, optional (default &#39;A.name-B.name&#39;)
        Name of the distribution for string representation.
        
    Example
    -------
    &gt;&gt;&gt; A = DU()
    &gt;&gt;&gt; A.convNeg(A) # returns A-A
    &gt;&gt;&gt; DiscreteDistribution.convNeg(A,A) # returns A-A
    &gt;&gt;&gt; A-A # returns A-A

    Returns
    -------
    DiscreteDistribution
        Difference of the distributions: `self-other`.
                
    &#34;&#34;&#34;
    s = f&#39;{self.name}-{other.name}&#39; if name is None else name     
    pk = np.convolve(self.pk, other.pk[::-1])
    xk = np.arange(self.xmin-other.xmax, self.xmax-other.xmin+1)
    return DiscreteDistribution(xk,pk,name=s)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.cx"><code class="name flex">
<span>def <span class="ident">cx</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the coefficient of the variation of the distribution <span><span class="MathJax_Preview"> c_X = STD[X]/E[X] </span><script type="math/tex"> c_X = STD[X]/E[X] </script></span>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Coefficient of variation of the distribution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cx(self):
    r&#34;&#34;&#34;Returns the coefficient of the variation of the distribution \( c_X = STD[X]/E[X] \).


    Returns
    -------
    float
        Coefficient of variation of the distribution.
        
    &#34;&#34;&#34;               
    return self.std()/self.mean()</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints basic characteristics of the distribution.
</p>
<p>This method prints basic characteristics of the distribution.</p>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; A.describe()
    interarrival_time: EX=5.5000, cX=0.5222, mode=1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self):
    r&#34;&#34;&#34;Prints basic characteristics of the distribution.        
    
    This method prints basic characteristics of the distribution.
    
    Example
    -------
    &gt;&gt;&gt; A.describe()
        interarrival_time: EX=5.5000, cX=0.5222, mode=1 
                    
    &#34;&#34;&#34;               
    print(f&#39;{self.name}: EX={self.mean():.4f}, cX={self.cx():.4f}, mode={self.mode()} &#39;)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the mean value of the distribution <span><span class="MathJax_Preview"> E[X] </span><script type="math/tex"> E[X] </script></span>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Mean value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(self):
    r&#34;&#34;&#34;Returns the mean value of the distribution \( E[X] \).


    Returns
    -------
    float
        Mean value.
        
    &#34;&#34;&#34;        
    return np.sum(self.xk*self.pk)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.mode"><code class="name flex">
<span>def <span class="ident">mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the mode of the distribution.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Mode of the distribution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mode(self):
    r&#34;&#34;&#34;Returns the mode of the distribution.


    Returns
    -------
    float
        Mode of the distribution.
        
    &#34;&#34;&#34;                
    return self.xk[np.argmax(self.pk)]</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.pi0"><code class="name flex">
<span>def <span class="ident">pi0</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the pi-operator (truncation of negative values, summing up probabilities ) and returns the resulting distribution.</p>
<p>The pi0-operator truncates the distribution at 0 and sums up the probabilities.
The probability mass of negative values is assigned to 0.
For the resulting distribution <span><span class="MathJax_Preview">X'</span><script type="math/tex">X'</script></span>, it is <span><span class="MathJax_Preview">P(X'=0 ) = \sum_{i=-\infty}^0 P(X=i)</span><script type="math/tex">P(X'=0 ) = \sum_{i=-\infty}^0 P(X=i)</script></span>, while the probabilites for all negative values
are set to zero <span><span class="MathJax_Preview">P(X'= i ) = 0, \forall i&lt;0</span><script type="math/tex">P(X'= i ) = 0, \forall i<0</script></span>. The rest of the distribution <span><span class="MathJax_Preview">i&gt;0 </span><script type="math/tex">i>0 </script></span> is not changed.</p>
<p><span><span class="MathJax_Preview">
\pi_0 \Big(x(k)\Big)
=
\begin{cases}
0 &amp; k &lt; 0 \\
\sum\limits_{i = - \infty}^0
x(i) &amp; k= 0 \\
x(k) &amp; k &gt; 0 \\
\end{cases}
</span><script type="math/tex; mode=display">
\pi_0 \Big(x(k)\Big)
=
\begin{cases}
0 & k < 0 \\
\sum\limits_{i = - \infty}^0
x(i) & k= 0 \\
x(k) & k > 0 \\
\end{cases}
</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'pi0(self.name)')</code></dt>
<dd>Name of the distribution for string representation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Truncated distribution.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>Generalized truncation </code>DiscreteDistribution.pi_op``</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pi0(self, name=None):
    r&#34;&#34;&#34;Applies the pi-operator (truncation of negative values, summing up probabilities ) and returns the resulting distribution.
    
    The pi0-operator truncates the distribution at 0 and sums up the probabilities.  The probability mass of negative values is assigned to 0. 
    For the resulting distribution \(X&#39;\), it is \(P(X&#39;=0 ) = \sum_{i=-\infty}^0 P(X=i)\), while the probabilites for all negative values 
    are set to zero \(P(X&#39;= i ) = 0, \forall i&lt;0\). The rest of the distribution \(i&gt;0 \) is not changed.
                        
    $$
    \pi_0 \Big(x(k)\Big)  =  \begin{cases}
            0 &amp; k &lt; 0 \\
            \sum\limits_{i = - \infty}^0
               x(i) &amp; k= 0 \\
            x(k) &amp; k &gt; 0 \\
    \end{cases} 
    $$
                                          
    Parameters
    ----------
    name : string, optional (default &#39;pi0(self.name)&#39;)
        Name of the distribution for string representation.
        
    Returns
    -------
    DiscreteDistribution
        Truncated distribution.

    See also
    -------
    Generalized truncation `DiscreteDistribution.pi_op`
    &#34;&#34;&#34;

    s = f&#39;pi0({self.name})&#39; if name is None else name
    return self.pi_op(m=0, name=s)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.pi_op"><code class="name flex">
<span>def <span class="ident">pi_op</span></span>(<span>self, m=0, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the pi-operator (summing up probabilities to m) and returns the resulting distribution.</p>
<p>The pi-operator truncates a distribution at the point <span><span class="MathJax_Preview">X=m</span><script type="math/tex">X=m</script></span> and sums up the probabilities.
The probability mass <span><span class="MathJax_Preview"> P(X\leq m) </span><script type="math/tex"> P(X\leq m) </script></span> is assigned
to the point <span><span class="MathJax_Preview">X=m</span><script type="math/tex">X=m</script></span>, while all other probabilities are set to zero for <span><span class="MathJax_Preview">X&lt;m</span><script type="math/tex">X<m</script></span>. The default operation is
to delete all negative values and assigning the probability mass of negative values to <span><span class="MathJax_Preview">X=0</span><script type="math/tex">X=0</script></span>.
Hence, the default value is <span><span class="MathJax_Preview">m=0</span><script type="math/tex">m=0</script></span> and in this case <span><span class="MathJax_Preview">P(X'=0 ) = \sum_{i=-\infty}^0 P(X=i)</span><script type="math/tex">P(X'=0 ) = \sum_{i=-\infty}^0 P(X=i)</script></span>, while the probabilites for all negative values
are set to zero <span><span class="MathJax_Preview">P(X'= i ) = 0, \forall i&lt;0</span><script type="math/tex">P(X'= i ) = 0, \forall i<0</script></span> for the resulting distribution <span><span class="MathJax_Preview">X'</span><script type="math/tex">X'</script></span>. The rest of the distribution <span><span class="MathJax_Preview">i&gt;0 </span><script type="math/tex">i>0 </script></span> is not changed.</p>
<p>In general: <span><span class="MathJax_Preview">P(X'=0 ) = \sum_{i=-\infty}^m P(X=i)</span><script type="math/tex">P(X'=0 ) = \sum_{i=-\infty}^m P(X=i)</script></span>. Hence, for a distribution <span><span class="MathJax_Preview">x(k)=P(X=k) </span><script type="math/tex">x(k)=P(X=k) </script></span>,
the pi-operator works as follows:</p>
<p><span><span class="MathJax_Preview">
\pi_m \Big(x(k)\Big)
=
\begin{cases}
0 &amp; k &lt; m \\
\sum\limits_{i = - \infty}^m
x(i) &amp; k= m \\
x(k) &amp; k &gt; m \\
\end{cases}
</span><script type="math/tex; mode=display">
\pi_m \Big(x(k)\Big)
=
\begin{cases}
0 & k < m \\
\sum\limits_{i = - \infty}^m
x(i) & k= m \\
x(k) & k > m \\
\end{cases}
</script></span>
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>integer</code></dt>
<dd>The truncation point at which probabilities are summed up.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'pi_m(self.name)')</code></dt>
<dd>Name of the distribution for string representation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Truncated distribution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pi_op(self, m=0, name=None):        
    r&#34;&#34;&#34;Applies the pi-operator (summing up probabilities to m) and returns the resulting distribution.
    
    The pi-operator truncates a distribution at the point \(X=m\) and sums up the probabilities. 
    The probability mass \( P(X\leq m) \) is assigned
    to the point \(X=m\), while all other probabilities are set to zero for \(X&lt;m\). The default operation is 
    to delete all negative values and assigning the probability mass of negative values to \(X=0\). 
    Hence, the default value is \(m=0\) and in this case \(P(X&#39;=0 ) = \sum_{i=-\infty}^0 P(X=i)\), while the probabilites for all negative values 
    are set to zero \(P(X&#39;= i ) = 0, \forall i&lt;0\) for the resulting distribution \(X&#39;\). The rest of the distribution \(i&gt;0 \) is not changed.
                                          
    In general: \(P(X&#39;=0 ) = \sum_{i=-\infty}^m P(X=i)\). Hence, for a distribution \(x(k)=P(X=k) \), 
    the pi-operator works as follows:

    $$
    \pi_m \Big(x(k)\Big)  =  \begin{cases}
            0 &amp; k &lt; m \\
            \sum\limits_{i = - \infty}^m
               x(i) &amp; k= m \\
            x(k) &amp; k &gt; m \\
    \end{cases} 
    $$                              
    
    Parameters
    ----------
    m : integer
        The truncation point at which probabilities are summed up.
    name : string, optional (default &#39;pi_m(self.name)&#39;)
        Name of the distribution for string representation.
        
    Returns
    -------
    DiscreteDistribution
        Truncated distribution.
                
    &#34;&#34;&#34;
    s = f&#39;pi_{m}({self.name})&#39; if name is None else name     
    if m &lt;= self.xmin:
        self.name = s
        return self
    elif m &gt;= self.xmax:
        return  DiscreteDistribution([m],[1],name=s)
    else:
        #s = f&#39;pi_{m}({A.name})&#39; if name is None else name        
        k = np.searchsorted(self.xk,m)
        xk = np.arange(m, self.xmax+1)
        pk = np.zeros(len(xk))
        pk[0] = np.sum(self.pk[0:k+1])
        pk[1:] = self.pk[k+1:]
        return DiscreteDistribution(xk,pk,name=s)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.plotCDF"><code class="name flex">
<span>def <span class="ident">plotCDF</span></span>(<span>self, addZero=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the cumulative distribution function of this distrribution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>addZero</code></strong> :&ensp;<code>bool (default True)</code></dt>
<dd>If true the zero point will be explicitly plotted, otherwise not.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Arbitrary keyword arguments are passed to <code>Matplotlib.pyplot.step</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotCDF(self,  addZero=True, **kwargs):
    r&#34;&#34;&#34;Plots the cumulative distribution function of this distrribution.

    Parameters
    ----------
    addZero : bool (default True)
        If true the zero point will be explicitly plotted, otherwise not.
    **kwargs: 
        Arbitrary keyword arguments are passed to `Matplotlib.pyplot.step`.
        
    Returns
    -------
    None
    &#34;&#34;&#34;                
    if addZero and self.xk[0]&gt;=0:
        x = np.insert(self.xk,0,0)
        y = np.insert(self.pk,0,0)
    else:
        x, y = self.xk, self.pk
    
    x = np.append(x, x[-1]+1)
    Y = np.append(y.cumsum(), 1)
    
    plt.step(x, Y, &#39;.-&#39;, where=&#39;post&#39;, **kwargs)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.plotPMF"><code class="name flex">
<span>def <span class="ident">plotPMF</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the probability mass function of this distrribution.</p>
<h2 id="parameters">Parameters</h2>
<p>**kwargs:
Arbitrary keyword arguments are passed to <code>Matplotlib.pyplot.plot</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotPMF(self,  **kwargs):
    r&#34;&#34;&#34;Plots the probability mass function of this distrribution.

    Parameters
    ----------        
    **kwargs: 
        Arbitrary keyword arguments are passed to `Matplotlib.pyplot.plot`.
        
    Returns
    -------
    None
    &#34;&#34;&#34;                
    plt.plot(self.xk, self.pk, &#39;.-&#39;, **kwargs)        </code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.pmf"><code class="name flex">
<span>def <span class="ident">pmf</span></span>(<span>self, xi)</span>
</code></dt>
<dd>
<div class="desc"><p>Probability mass function at xi of the given distribution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>numpy array</code> or <code>integer</code></dt>
<dd>Quantiles.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy array</code> of <code>float</code></dt>
<dd>Probability mass function evaluated at xi.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pmf(self, xi):
    r&#34;&#34;&#34;Probability mass function at xi of the given distribution.

    Parameters
    ----------
    xi : numpy array or integer
        Quantiles.
        
    Returns
    -------
    numpy array of float
        Probability mass function evaluated at xi.
    &#34;&#34;&#34;                
    #myxk = np.arange(self.xmin-1, self.xmax+2)
    #mypk = np.hstack((0, self.pk, 0))
    if type(xi) is not np.ndarray:
        if type(xi) is list:
            xi = np.array(xi)
        else:
            xi = np.array([xi])
    
    i = np.where( (xi&gt;=self.xmin) &amp; (xi&lt;=self.xmax) )[0]
    mypk = np.zeros(len(xi))
    
    if len(i)&gt;0:            
        mypk[i] = self.pk[np.searchsorted(self.xk, xi[i], side=&#39;left&#39;)]
    return mypk</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.quantile"><code class="name flex">
<span>def <span class="ident">quantile</span></span>(<span>self, q=0.95)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the q-quantile of the distribution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>q</code></strong> :&ensp;<code>float</code>, optional <code>(default 0.95)</code></dt>
<dd>The parameter indicates that the q-quantile is derived. The default value is <code>q=0.95</code>
for the 95%-quantile. It must be ensured that <span><span class="MathJax_Preview"> 0&lt; q &lt; 1</span><script type="math/tex"> 0< q < 1</script></span>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>q-Quantile (default 95%) of the distribution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quantile(self, q=0.95):
    r&#34;&#34;&#34;Returns the q-quantile of the distribution.

    Parameters
    ----------
    q : float, optional (default 0.95)
        The parameter indicates that the q-quantile is derived. The default value is `q=0.95`
        for the 95%-quantile. It must be ensured that \( 0&lt; q &lt; 1\).

    Returns
    -------
    float
        q-Quantile (default 95%) of the distribution.
        
    &#34;&#34;&#34;                
    return self.xk[np.argmax(self.pk.cumsum()&gt;q)]</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.sigmaTakeGEQ"><code class="name flex">
<span>def <span class="ident">sigmaTakeGEQ</span></span>(<span>self, m=0, name=None, normalized=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the sigma-operator and returns the result.</p>
<p>The sigma-operator returns the lower or the upper part of the distribution.
<code>sigmaTakeGEQ</code> implements the <span><span class="MathJax_Preview">\sigma_m</span><script type="math/tex">\sigma_m</script></span>-operator which sweeps away the lower part <span><span class="MathJax_Preview">k &lt; m </span><script type="math/tex">k < m </script></span>
and takes the upper part <span><span class="MathJax_Preview"> k \geq m </span><script type="math/tex"> k \geq m </script></span>. The distribution is therefore truncated.
The results of these operations are unnormalized distributions where the sum of the probabilities
is less than one:
<span><span class="MathJax_Preview">
\sigma_m[x(k)] =
\begin{cases}
0 &amp; k&lt;m \\
x(k) &amp; k \geq m
\end{cases}
</span><script type="math/tex; mode=display">
\sigma_m[x(k)] =
\begin{cases}
0 & k<m \\
x(k) & k \geq m
\end{cases}
</script></span></p>
<p>The parameter <code>normalized</code> (default True) indicates that a normalized distribution
(conditional random variable) is returned, such that the sum of probabilities is one.
The parameter <code>m</code> indicates at which point the distribution is truncated.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>integer</code></dt>
<dd>Truncation point. The upper part <span><span class="MathJax_Preview">k\geq m</span><script type="math/tex">k\geq m</script></span> of the distribution is taken.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'sigma_{m}({self.name})')</code></dt>
<dd>Name of the distribution for string representation.</dd>
<dt><strong><code>normalized</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true returns a normalized distribution. If false the original probabilities for the
truncated range are returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Returns normalized or unnormalized truncated distribution taking probabilities for <span><span class="MathJax_Preview">k \geq m </span><script type="math/tex">k \geq m </script></span>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sigmaTakeGEQ(self, m=0, name=None, normalized=True):
    r&#34;&#34;&#34;Applies the sigma-operator and returns the result.
    
    The sigma-operator returns the lower or the upper part of the distribution. 
    `sigmaTakeGEQ` implements the \(\sigma_m\)-operator which sweeps away the lower part \(k &lt; m \) 
    and takes the upper part \( k \geq m \). The distribution is therefore truncated. 
    The results of these operations are unnormalized distributions where the sum of the probabilities
    is less than one:
    $$    
    \sigma_m[x(k)] = 
            \begin{cases}
            0 &amp; k&lt;m \\
            x(k) &amp; k \geq m
            \end{cases} 
    $$

    The parameter `normalized` (default True) indicates that a normalized distribution
    (conditional random variable) is returned, such that the sum of probabilities is one.
    The parameter `m` indicates at which point the distribution is truncated.
    
    Parameters
    ----------
    m : integer
        Truncation point. The upper part \(k\geq m\) of the distribution is taken.        
    name : string, optional (default &#39;sigma_{m}({self.name})&#39;)
        Name of the distribution for string representation.
    normalized : bool
        If true returns a normalized distribution. If false the original probabilities for the 
        truncated range are returned. 
        
    Returns
    -------
    DiscreteDistribution
        Returns normalized or unnormalized truncated distribution taking probabilities for \(k \geq m \).

    &#34;&#34;&#34;
    s = f&#39;sigma_{m}({self.name})&#39; if name is None else name     
    #assert m&gt;=self.xk[0]
    if m&gt;self.xk[-1]:
        if normalized: 
            raise ValueError(&#39;sigmaGEQ: m &gt; max(xk)&#39;)
        else:
            return DiscreteDistribution([m], [0], name=s)                    
    
    first = np.searchsorted(self.xk, m, side=&#39;left&#39;)
    
    xk=self.xk[first:]
    if normalized:
        prob_Dist_U_geq_m = self.pk[first:].sum() 
        pk=self.pk[first:] / prob_Dist_U_geq_m
    else:
        pk=self.pk[first:]                
    return DiscreteDistribution(xk, pk, name=s)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.sigmaTakeLT"><code class="name flex">
<span>def <span class="ident">sigmaTakeLT</span></span>(<span>self, m=0, name=None, normalized=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the sigma-operator and returns the result.</p>
<p>The sigma-operator returns the lower or the upper part of the distribution.
<code>sigmaTakeLT</code> implements the <span><span class="MathJax_Preview">\sigma^m</span><script type="math/tex">\sigma^m</script></span>-operator which sweeps away the upper part <span><span class="MathJax_Preview">k\geq m</span><script type="math/tex">k\geq m</script></span>
and takes the lower part <span><span class="MathJax_Preview">k &lt; m </span><script type="math/tex">k < m </script></span>. The distribution is therefore truncated.
The results of these operations are unnormalized distributions where the sum of the probabilities
is less than one:
<span><span class="MathJax_Preview">\sigma^m[x(k)] =
\begin{cases}
x(k) &amp; k&lt;m \\
0 &amp; k \geq m
\end{cases}
</span><script type="math/tex; mode=display">\sigma^m[x(k)] =
\begin{cases}
x(k) & k<m \\
0 & k \geq m
\end{cases}
</script></span></p>
<p>The parameter <code>normalized</code> (default True) indicates that a normalized distribution
(conditional random variable) is returned, such that the sum of probabilities is one.
The parameter <code>m</code> indicates at which point the distribution is truncated.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>integer</code></dt>
<dd>Truncation point. The lower part <span><span class="MathJax_Preview">k &lt; m </span><script type="math/tex">k < m </script></span> of the distribution is taken.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional <code>(default 'sigma^{m}({self.name})')</code></dt>
<dd>Name of the distribution for string representation.</dd>
<dt><strong><code>normalized</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true returns a normalized distribution. If false the original probabilities for the
truncated range are returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></dt>
<dd>Returns normalized or unnormalized truncated distribution taking probabilities for <span><span class="MathJax_Preview">k &lt; m </span><script type="math/tex">k < m </script></span>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If m is less than the smallest value xmin of this distribution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sigmaTakeLT(self, m=0, name=None, normalized=True):        
    r&#34;&#34;&#34;Applies the sigma-operator and returns the result.
    
    The sigma-operator returns the lower or the upper part of the distribution. 
    `sigmaTakeLT` implements the \(\sigma^m\)-operator which sweeps away the upper part \(k\geq m\) 
    and takes the lower part \(k &lt; m \). The distribution is therefore truncated. 
    The results of these operations are unnormalized distributions where the sum of the probabilities
    is less than one:
    $$\sigma^m[x(k)] = 
            \begin{cases}
            x(k) &amp; k&lt;m \\
            0 &amp; k \geq m 
    \end{cases}
    $$

    The parameter `normalized` (default True) indicates that a normalized distribution
    (conditional random variable) is returned, such that the sum of probabilities is one.
    The parameter `m` indicates at which point the distribution is truncated.
    
    Parameters
    ----------
    m : integer
        Truncation point. The lower part \(k &lt; m \) of the distribution is taken.        
    name : string, optional (default &#39;sigma^{m}({self.name})&#39;)
        Name of the distribution for string representation.
    normalized : bool
        If true returns a normalized distribution. If false the original probabilities for the 
        truncated range are returned. 
        
    Returns
    -------
    DiscreteDistribution
        Returns normalized or unnormalized truncated distribution taking probabilities for \(k &lt; m \).            

    Raises
    ------
    ValueError
        If m is less than the smallest value xmin of this distribution. 
        
    &#34;&#34;&#34;                
    #assert m&lt;xk[-1]
    s = f&#39;sigma^{m}({self.name})&#39; if name is None else name     
            
    if m&lt;=self.xk[0]:
        if normalized: 
            raise ValueError(&#39;sigmaLT: m &lt; min(xk)&#39;)
        else:
            return DiscreteDistribution([m], [0], name=s)
    if m&gt;self.xk[-1]:
        return DiscreteDistribution(self.xk, self.pk, name=s)
        
    last = np.searchsorted(self.xk, m, side=&#39;right&#39;)-1        
    
    xk=self.xk[:last]
    if normalized:
        prob_Dist_U_lt_m = self.pk[:last].sum() 
        pk=self.pk[:last] / prob_Dist_U_lt_m
    else:
        pk=self.pk[:last]                
    return DiscreteDistribution(xk, pk, name=s)</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.std"><code class="name flex">
<span>def <span class="ident">std</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the standard deviation of the distribution <span><span class="MathJax_Preview"> {STD}[X]=\sqrt{VAR[X]} </span><script type="math/tex"> {STD}[X]=\sqrt{VAR[X]} </script></span>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Standard deviation of the distribution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def std(self):
    r&#34;&#34;&#34;Returns the standard deviation of the distribution \( {STD}[X]=\sqrt{VAR[X]} \).


    Returns
    -------
    float
        Standard deviation of the distribution.
        
    &#34;&#34;&#34;                
    return math.sqrt(self.var())</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.trim"><code class="name flex">
<span>def <span class="ident">trim</span></span>(<span>self, normalize=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove trailing and leading diminishing probabilities. </p>
<p>The trim-operation changes the value range <code>xk</code> and the corresponding probabilities <code>pk</code> by removing
any leading and any trailing diminishing probabilities. This distribution object is therefore changed.</p>
<h2 id="parameters">Parameters</h2>
<p>normalize : bool
If True, the distribution is renormalized. If False, the distribution is truncated.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trim(self, normalize=True):
    r&#34;&#34;&#34;Remove trailing and leading diminishing probabilities. 
    
    The trim-operation changes the value range `xk` and the corresponding probabilities `pk` by removing
    any leading and any trailing diminishing probabilities. This distribution object is therefore changed.
    
    Parameters
    ----------        
    normalize : bool
        If True, the distribution is renormalized. If False, the distribution is truncated.

    Returns
    -------
    None
    &#34;&#34;&#34;                
    m = self.pk!=0        
    self._trim(m, normalize)
    return </code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.trimCDF"><code class="name flex">
<span>def <span class="ident">trimCDF</span></span>(<span>self, eps=1e-08, normalize=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove trailing and leading diminishing cumulative probabilities below a certain threshold. </p>
<p>The trimCDF-operation changes the value range <code>xk</code> and the corresponding probabilities <code>pk</code>
by removing any leading and any trailing diminishing cumulative probabilities which are less than <code>eps</code>.
This distribution object is therefore changed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code></dt>
<dd>Threshold which leading or trailing cumulative probabilities are to be removed.</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, the distribution is renormalized. If False, the distribution is truncated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trimCDF(self, eps=1e-8, normalize=True):
    r&#34;&#34;&#34;Remove trailing and leading diminishing cumulative probabilities below a certain threshold. 
    
    The trimCDF-operation changes the value range `xk` and the corresponding probabilities `pk` 
    by removing any leading and any trailing diminishing cumulative probabilities which are less than `eps`. 
    This distribution object is therefore changed.

    Parameters
    ----------
    eps : float
        Threshold which leading or trailing cumulative probabilities are to be removed.
    normalize : bool
        If True, the distribution is renormalized. If False, the distribution is truncated.
        
    Returns
    -------
    None        
    &#34;&#34;&#34;                
    m = self.pk.cumsum()&gt;eps #!=0        
    self._trim(m, normalize)
    return    </code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.trimPMF"><code class="name flex">
<span>def <span class="ident">trimPMF</span></span>(<span>self, eps=1e-08, normalize=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove trailing and leading diminishing probabilities below a certain threshold. </p>
<p>The trimPMF-operation changes the value range <code>xk</code> and the corresponding probabilities <code>pk</code> by removing
any leading and any trailing diminishing probabilities which are less than <code>eps</code>.
This distribution object is therefore changed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code></dt>
<dd>Threshold which leading or trailing probabilities are to be removed.</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, the distribution is renormalized. If False, the distribution is truncated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trimPMF(self, eps=1e-8, normalize=True):
    r&#34;&#34;&#34;Remove trailing and leading diminishing probabilities below a certain threshold. 
    
    The trimPMF-operation changes the value range `xk` and the corresponding probabilities `pk` by removing
    any leading and any trailing diminishing probabilities which are less than `eps`. 
    This distribution object is therefore changed.

    Parameters
    ----------
    eps : float
        Threshold which leading or trailing probabilities are to be removed.
    normalize : bool
        If True, the distribution is renormalized. If False, the distribution is truncated.
        
    Returns
    -------
    None        

    &#34;&#34;&#34;                
    m = self.pk&gt;eps #!=0        
    self._trim(m, normalize)
    return</code></pre>
</details>
</dd>
<dt id="discreteTimeAnalysis.DiscreteDistribution.var"><code class="name flex">
<span>def <span class="ident">var</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the variance of the distribution <span><span class="MathJax_Preview"> VAR[X] </span><script type="math/tex"> VAR[X] </script></span>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Variance of the distribution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def var(self):
    r&#34;&#34;&#34;Returns the variance of the distribution \( VAR[X] \).


    Returns
    -------
    float
        Variance of the distribution.
        
    &#34;&#34;&#34;                
    return np.sum(self.xk**2*self.pk)-self.mean()**2</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#example">Example</a></li>
<li><a href="#operators">Operators</a></li>
<li><a href="#notes">Notes</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="discreteTimeAnalysis.comparisonEQ_eps" href="#discreteTimeAnalysis.comparisonEQ_eps">comparisonEQ_eps</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="discreteTimeAnalysis.BER" href="#discreteTimeAnalysis.BER">BER</a></code></li>
<li><code><a title="discreteTimeAnalysis.BINOM" href="#discreteTimeAnalysis.BINOM">BINOM</a></code></li>
<li><code><a title="discreteTimeAnalysis.DET" href="#discreteTimeAnalysis.DET">DET</a></code></li>
<li><code><a title="discreteTimeAnalysis.DU" href="#discreteTimeAnalysis.DU">DU</a></code></li>
<li><code><a title="discreteTimeAnalysis.GEOM" href="#discreteTimeAnalysis.GEOM">GEOM</a></code></li>
<li><code><a title="discreteTimeAnalysis.GIGI1_waitingTime" href="#discreteTimeAnalysis.GIGI1_waitingTime">GIGI1_waitingTime</a></code></li>
<li><code><a title="discreteTimeAnalysis.MIX" href="#discreteTimeAnalysis.MIX">MIX</a></code></li>
<li><code><a title="discreteTimeAnalysis.NEGBIN" href="#discreteTimeAnalysis.NEGBIN">NEGBIN</a></code></li>
<li><code><a title="discreteTimeAnalysis.POIS" href="#discreteTimeAnalysis.POIS">POIS</a></code></li>
<li><code><a title="discreteTimeAnalysis.conv" href="#discreteTimeAnalysis.conv">conv</a></code></li>
<li><code><a title="discreteTimeAnalysis.getNegBinPars" href="#discreteTimeAnalysis.getNegBinPars">getNegBinPars</a></code></li>
<li><code><a title="discreteTimeAnalysis.kingman" href="#discreteTimeAnalysis.kingman">kingman</a></code></li>
<li><code><a title="discreteTimeAnalysis.lindley_equation" href="#discreteTimeAnalysis.lindley_equation">lindley_equation</a></code></li>
<li><code><a title="discreteTimeAnalysis.max" href="#discreteTimeAnalysis.max">max</a></code></li>
<li><code><a title="discreteTimeAnalysis.pi0" href="#discreteTimeAnalysis.pi0">pi0</a></code></li>
<li><code><a title="discreteTimeAnalysis.pi_op" href="#discreteTimeAnalysis.pi_op">pi_op</a></code></li>
<li><code><a title="discreteTimeAnalysis.plotCDF" href="#discreteTimeAnalysis.plotCDF">plotCDF</a></code></li>
<li><code><a title="discreteTimeAnalysis.plotPMF" href="#discreteTimeAnalysis.plotPMF">plotPMF</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="discreteTimeAnalysis.DiscreteDistribution" href="#discreteTimeAnalysis.DiscreteDistribution">DiscreteDistribution</a></code></h4>
<ul class="two-column">
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.cdf" href="#discreteTimeAnalysis.DiscreteDistribution.cdf">cdf</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.checkDistribution" href="#discreteTimeAnalysis.DiscreteDistribution.checkDistribution">checkDistribution</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.conditionalRV" href="#discreteTimeAnalysis.DiscreteDistribution.conditionalRV">conditionalRV</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.conv" href="#discreteTimeAnalysis.DiscreteDistribution.conv">conv</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.convNeg" href="#discreteTimeAnalysis.DiscreteDistribution.convNeg">convNeg</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.cx" href="#discreteTimeAnalysis.DiscreteDistribution.cx">cx</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.describe" href="#discreteTimeAnalysis.DiscreteDistribution.describe">describe</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.mean" href="#discreteTimeAnalysis.DiscreteDistribution.mean">mean</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.mode" href="#discreteTimeAnalysis.DiscreteDistribution.mode">mode</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.pi0" href="#discreteTimeAnalysis.DiscreteDistribution.pi0">pi0</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.pi_op" href="#discreteTimeAnalysis.DiscreteDistribution.pi_op">pi_op</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.plotCDF" href="#discreteTimeAnalysis.DiscreteDistribution.plotCDF">plotCDF</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.plotPMF" href="#discreteTimeAnalysis.DiscreteDistribution.plotPMF">plotPMF</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.pmf" href="#discreteTimeAnalysis.DiscreteDistribution.pmf">pmf</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.quantile" href="#discreteTimeAnalysis.DiscreteDistribution.quantile">quantile</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.sigmaTakeGEQ" href="#discreteTimeAnalysis.DiscreteDistribution.sigmaTakeGEQ">sigmaTakeGEQ</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.sigmaTakeLT" href="#discreteTimeAnalysis.DiscreteDistribution.sigmaTakeLT">sigmaTakeLT</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.std" href="#discreteTimeAnalysis.DiscreteDistribution.std">std</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.trim" href="#discreteTimeAnalysis.DiscreteDistribution.trim">trim</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.trimCDF" href="#discreteTimeAnalysis.DiscreteDistribution.trimCDF">trimCDF</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.trimPMF" href="#discreteTimeAnalysis.DiscreteDistribution.trimPMF">trimPMF</a></code></li>
<li><code><a title="discreteTimeAnalysis.DiscreteDistribution.var" href="#discreteTimeAnalysis.DiscreteDistribution.var">var</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>